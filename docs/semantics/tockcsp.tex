%!TEX root=../robocert.tex

This section introduces a \tockcsp{} semantics for \langname.
\todo{Need to make sure it's actually \tockcsp, not CSP.}
This semantics is inspired by that of Lima et al. on the CML semantics of
UML sequence diagrams.

The behaviour of the \langname{} generator is expected to conform to
this semantics, except that:

\begin{itemize}
\item
	The generator targets \cspm{} instead of CSP, and so \emph{may}
	use semantically equivalent \cspm{} constructs where the CSP equivalents
	are missing or not idiomatic;
\item
	The generator \emph{may} \todo{not yet but eventually} wrap processes in
	timed sections to achieve the appropriate \tockcsp{} behaviours of
	CSP operators;
\item
	The generator \emph{may} perform semantics-preserving optimisations,
	such as substituting \(P\) for \(\tlang{\Stop \interrupt{}}P\).
\end{itemize}

\todo{Some of the definitions are very loosely typed (as they are expanding from
a metamodel to textual snippets of something halfway between \tockcsp{} and
\cspm), and it'd be nice to fix that and/or give explicit result types.}

\subsection{Packages}\label{ssec:semantics-tockcsp-top}

The definitions here correspond to \cref{sec:metamodel-top}.

\begin{defn}[\mrapackage]
The semantics of \mrapackage{} is the concatenation of the semantics of its
components, acquired by mapping the respective semantic functions through the
component sequences.
\todo{This should really return one \tockcsp{} element, not a sequence of them.}
%
\begin{align*}
	\pkgsema{\apkg}
\quad\defeq\quad&
	(\cspsema{-} \circ (\field{\acsp}{cspFragments}))
\cat
	(\seqsema{-} \circ (\field{\acsp}{sequences}))
\cat
	(\asstsema{-} \circ (\field{\acsp}{assertion}))
\end{align*}
\end{defn}

\begin{defn}[\mcspfragment]
For now, the semantics of a CSP fragment is its contents directly interpreted
as \tockcsp.  This will change later on; CSP fragments will eventually be bound
to processes as in \robochart{} assertions.
%
\begin{align*}
	\cspsema{\acsp}
\quad\defeq\quad&
	\field{\acsp}{contents}
\end{align*}
\end{defn}


\subsection{Sequences}\label{ssec:semantics-tockcsp-sequences}

The definitions here correspond to \cref{sec:metamodel-sequences}.

\begin{defn}[\msequence]

The semantics of a \msequence{} introduces three bindings: one for the
definition of its \msubsequence, and one each for the open and closed forms of
its \mtarget{} (\cref{ssec:semantics-tockcsp-actors}).
\todo{this is a module in \cspm, can we define it this way in \tockcsp?}
%
\begin{align*}
	\seqsema{\aseq}
\quad\defeq\quad&	
\langle
	\seqnameOf{\aseq}\ =\ \sseqsema{\field{\aseq}{body}}
	, \otargetsema{\field{\aseq}{target}}
	, \ctargetsema{\field{\aseq}{target}}\rangle
\\
\intertext{The semantics of assertions depends on the following names being
available \todo{is this an implementation detail?}:}
	\seqnameOf{\aseq}
\quad\defeq\quad&
	\field{\aseq}{name} \tlang{{} \cspnsop \text{Sequence}}
\\
	\otargetnameOf{\aseq}
\quad\defeq\quad&
	\field{\aseq}{name} \tlang{{} \cspnsop \text{OpenTarget}}
\\
	\ctargetnameOf{\aseq}
\quad\defeq\quad&
	\field{\aseq}{name} \tlang{{} \cspnsop \text{Target}}
\end{align*}

\end{defn}

\begin{defn}[\msubsequence]

The semantics of a \msubsequence{} is a sequential composition of that of its steps.
%
\begin{align*}
	\sseqsema{\asseq}
	\quad\defeq\quad&	
	\funcname{steps}(\field{\asseq}{body})
\\
	\funcname{steps}(\langle \astep_1, \dotsc, \astep_n \rangle)
	\quad\defeq\quad&	
	\stepsema{\astep_1} \tlang{\circseq} \dotso \tlang{\circseq} \stepsema{\astep_n}
\end{align*}

\end{defn}

\begin{defn}[\msequencestep]

The semantics of a \msequencestep{} is an unbounded loop over the events of its
\msequencegap, interrupted by the \msequenceaction.\footnote{Note that the semantics of the gap depends
on the action.  This is because, as seen in \(\gapsema{\agap}{\anaction}\),
the events on which the action can interrupt the
gap must be removed from the events of the gap to ensure the interrupt has the
expected semantics.}
%
\begin{align*}
	\stepsema{\astep}
\quad\defeq\quad&	
	\tlang{
		\runproc{\olang{\gapsema{\field{\astep}{gap}}{\field{\astep}{action}}}}
		\interrupt \olang{\actsema{\field{\astep}{action}}}
	}
\end{align*}
\end{defn}

\begin{defn}[\msequencegap]
	The semantics of a \msequencegap{} is the CSP event set corresponding to
	the difference between the \emph{allowed} set,
	and the result of extending the \emph{forbidden} set with any events
	the action following the gap can initially communicate.
	\todo{Should these set operations be done at CSP level?}
%
\begin{align*}
	\gapsema{
		\agap
	}{\anaction}
\quad\defeq\quad&
\tlang{
	\olang{\msgsetsema{\field{\agap}{allowed}}}
	\setminus
	\left(
		\olang{\msgsetsema{\field{\agap}{forbidden}}}
		\cup
		\olang{\eventsOf{\anaction}}
	\right)
}
\end{align*}
\end{defn}

\begin{defn}[CSP event sets]
For now, the event set of an action is the prefix of an arrow action, or
the empty set for any other actions.  This will change when the prefix becomes
inexpressible as an event set.
%
\begin{align*}
	\eventsOf{\anarrow}
\quad\defeq\quad&
	\tlang{\Set{\olang{\mspecsema{\anarrow}}}}
	\tag{arrow}
\\
	\eventsOf{\anaction}
\quad\defeq\quad&
	\tlang{\emptyset}
	\tag{anything else}
\end{align*}
\end{defn}

\begin{defn}[\mgapmessageset]

Note that, per \cref{ssec:metamodel-sequences-gaps}, gap message sets in the
\emph{allowed} position can be either \mextensionalgapmessageset s or
\muniversegapmessageset s; we treat both using the same rule.
%
\begin{align*}
	\msgsetsema{\aumsgset}
\quad\defeq\quad&
	\tlang{\events}
\tag{universe}
\\
\intertext{\todo{For now, the semantics of an \mextensionalgapmessageset{} treats each
message
spec as if it were an \marrowmessagespec.  This will change when arrow and gap
message specs diverge.}\todo{The meta/object language distinction is messy here
and I'm not sure how to handle it.}}
	\msgsetsema{\anemsgset}
\quad\defeq\quad&
	\tlang{\bigcup}
	\Set{
		\mspecsema{\amspec} | \amspec \in \field{\anemsgset}{messages}
	}
\tag{extensional}
\end{align*}
\end{defn}

\subsection{Actions}\label{ssec:semantics-tockcsp-actions}

The definitions here correspond to \cref{sec:metamodel-actions}.

\begin{defn}[\msequenceaction]

The semantics of an arrow action is the semantics of its arrow as a CSP prefix,
prefixing termination.  The semantics of a loop delegates to a separate rule
over its label and subsequence.
%
\begin{align*}
	\actsema{\anarrow}
\quad\defeq\quad&
	\tlang{
	\left(
	\olang{\mspecsema{\anarrow}}
	\then
	\Skip
	\right)
	}
	\tag{arrow action}
\\
	\actsema{\aloop}
\quad\defeq\quad&
	\loopsema{\aloop}
\tag{loop action}
\\
\intertext{For now, a \mfinalaction{} does not terminate.}
	\actsema{\bot}
\quad\defeq\quad&
	\tlang{\Stop}
\tag{final action}
\end{align*}

\end{defn}

\begin{defn}[\mloopaction]

For now, only infinite loops exist, and their semantics is that of the loop
subsequence placed in a recursive process.
%
\begin{align*}
	\loopsema{\aloop}
\quad\defeq\quad&
\tlang{
	\circmu \mathsf{LOOP}_{\olang{\field{\aloop}{name}}} \bullet
	\left(
		\olang{\sseqsema{\field{\aloop}{body}}}
		\circseq \mathsf{LOOP}_{\olang{\field{\aloop}{name}}}
	\right)
}
\tag{infinite loop}
\end{align*}

\end{defn}

\subsection{Messages}\label{ssec:semantics-tockcsp-messages}

The definitions here correspond to \cref{sec:metamodel-messages}.

\begin{defn}[\mmessagespec]

The semantics of \mmessagespec s\footnote{For now, \mgapmessagespec s and
\marrowmessagespec s are equivalent in semantics; this may change later on.}
depends on the topic of their message specs,
and, for certain topics, the direction (inbound from world to target, or
outbound from target to world).  For now, neither operations nor events can have
arguments.

\newcommand{\nsOf}[1]{\mathsf{ns}(#1)}
\newcommand{\targetOf}[2]{\mathsf{target}(#1,#2)}
\newcommand{\topicOf}[3]{\mathsf{topic}(#1,#2,#3)}

Let \(\nsOf{\atarget}\) be the name of the module, controller, or state machine
referred to by \(\atarget\).
%
\begin{align*}
	\mspecsema{\anarrow}
\quad\defeq\quad&
	\nsOf{\targetOf{\field{\anarrow}{from}}{\field{\anarrow}{to}}}
	\tlang{{}\cspnsop{}}
	\topicOf{\field{\anarrow}{topic}}{\field{\anarrow}{from}}{\field{\anarrow}{to}}
\\
	\targetOf{\aworld}{\atarget}
\quad\defeq\quad&
	\targetOf{\atarget}{\aworld}
	\quad\defeq\quad
	\atarget
\\
	\topicOf{\anop}{\atarget}{\aworld}
\quad\defeq\quad&
	\field{\anop}{name}\tlang{\text{Call}}
\\
	\topicOf{\anevent}{\aworld}{\atarget}
\quad\defeq\quad&
	\field{\anevent}{name}\tlang{.\text{in}}
\\
	\topicOf{\anevent}{\atarget}{\aworld}
\quad\defeq\quad&
	\field{\anevent}{name}\tlang{.\text{out}}
\end{align*}

\end{defn}

\subsection{Actors}\label{ssec:semantics-tockcsp-actors}

The definitions here correspond to \cref{sec:metamodel-actors}.

\todo{This part might be overly low-level, I'm not sure.  It's
maybe exposing a public interface between sequences and assertions, hence why
it's in this semantics?}

There are four rules for \mtarget{}s, corresponding to whether a
\emph{definition} or a \emph{reference} is required for the
\mtarget, and whether the target is \emph{open}
(exposes as parameters any constants not otherwise defined) or
\emph{closed} (delegates said parameters to names bound
in its parent scope).  Assertions use the closed form if there is no
assertion-level \mtargetinstantiation, and the open form in terms of the
instantiation otherwise.

We assume three external functions bridging this semantics with that of
\robochart{} etc. \todo{should we define these, or at least partially
define them, here?}:

\begin{itemize}
\item
	let \funcname{targetProcess} map a target to the parametric
	process exposed by the relevant \tockcsp{} semantics (for instance,
	we delegate to the \robochart{} semantics for the underlying
	\mrcmodule{} of a \mrcmoduletarget);
	\todo{doesn't account for the ID parameter in certain target
	processes};
\item
	let \funcname{targetParams} map a target to the sequence of
	constants in its parameterisation;
\item
	let \funcname{constName} map a constant to its name in the \robochart{}
	instantiations file.
\end{itemize}

\begin{defn}[\mtarget{} open definition]

The open definition produces a CSP process named
\(\otargetnameOf{\field{\atarget}{sequence}}\), parameterised by the
uninstantiated remainder of the process parameters of \(\atarget\), and
defined as the process of \(\atarget\) with each argument filled as follows:
for each parameter in the underlying target process, its
target-level instantiation where present, and the corresponding outer
parameter via \funcname{constName} where absent.

\todo{Some type issues here, eg using \funcname{constName} as both a parameter
and an expression}
%
\begin{align*}
	\otargetsema{\atarget}
\quad\defeq\quad&
\begin{aligned}
&
	\otargetnameOf{\field{\atarget}{sequence}}
	\tlang{
	\left(
		\olang{\funcname{constName}\ \circ\ \funcname{uninstantiated}(\atarget)}
	\right)
	}
\\
&
	\tlang{\quad=\quad}
	\funcname{targetProcess}(\atarget)
	\tlang{
	\left(
	\olang{
	\funcname{orOuter}(\field{\atarget}{instantiation})
	\circ
	\funcname{targetParams}(\atarget)
	}
	\right)
	}
\end{aligned}
\\
	\funcname{uninstantiated}(\atarget)
\quad\defeq\quad&
	\funcname{targetParams}(\atarget)
	\filter
	\left(\universe \setminus \ran \field{\aninst}{constants}\right)
\\
	\funcname{orOuter}(\aninst)
\quad\defeq\quad&
	\funcname{constName} \oplus \aninst
\end{align*}
\end{defn}

\begin{defn}[\mtarget{} open reference]
The semantics of an open reference is similar to the body of an open definition,
as it distributes an instantiation across process parameters to yield arguments.
In this case, we assume each name \(\funcname{constName}(\avar)\) resolves to an
external default definition for constant \(\avar\).
%
\begin{align*}
	\otargetRef{\atarget}{\aninst}
\quad\defeq\quad&
	\otargetnameOf{\field{\atarget}{sequence}}
	\tlang{
	\left(
	\olang{
	\funcname{orOuter}(\aninst)\ \circ\ \funcname{uninstantiated}(\atarget)
	}
	\right)
	}
\end{align*}
\end{defn}

\begin{defn}[\mtarget{} closed definition]
A closed definition encapsulates an open reference against the instantiation of
the target itself; as the open target does not expose any of the parameters
defined by this instantiation, this effectively leaves all exposed parameters
set to their default values.
\todo{This could theoretically be an empty instantiation too.}
%
\begin{align*}
	\ctargetsema{\atarget}
\quad\defeq\quad&
	\ctargetnameOf{\field{\atarget}{sequence}}
	\tlang{\;=\;}
	\otargetRef{\atarget}{\field{\atarget}{instantiation}}
\end{align*}
\end{defn}

\begin{defn}[\mtarget{} closed reference]
A closed reference is the name assigned at \msequence{} level to the closed
target process (since such processes have no parameters).
%
\begin{align*}
\ctargetRef{\atarget}
\quad\defeq\quad&
\ctargetnameOf{\field{\atarget}{sequence}}
\end{align*}
\end{defn}

Once we have the open and closed references, we can choose between them
depending on whether an assertion \mtargetinstantiation{} is empty.

\begin{defn}[\mtarget{} reference]
\begin{align*}
\targetRef{\atarget}{\aninst}
\quad\defeq\quad
\begin{cases}
	\ctargetRef{\atarget} & \field{\aninst}{constants} = \emptyset
	\\
	\otargetRef{\atarget}{\aninst} & \text{otherwise}
\end{cases}
\end{align*}
\end{defn}

\subsection{Assertions}

The definitions here correspond to \cref{sec:metamodel-assertions}.

\begin{defn}[\massertion]

\newcommand{\refop}[3]{\mathbin{\odot_{#1}^{(#2, #3)}}}

The only type of assertion so far is \msequenceassertion.  The semantics of a
\msequenceassertion{} relates the \msequence{} of the assertion to the
\mtarget{} of the assertion.
%
\begin{align*}
	\asstsema{\asasst}
\quad\defeq\quad&
	\seqnameOf{\field{\asasst}{sequence}}
	\;
	\refop{\field{\asasst}{model}}{\field{\asasst}{isNegated}}{\field{\asasst}{type}}
	\;
	\targetRef{\field{\field{\asasst}{sequence}}{target}}{\field{\asasst}{instantiation}}
\\
\intertext{The exact refinement operator depends on the assertion type and
negation:}
	\refop{\amodel}{\true}{\mathsf{holds}}
\quad\defeq\quad&
	\tlang{\sqsubseteq}_\amodel
\tag{holds}
\\
	\refop{\amodel}{\false}{\mathsf{holds}}
\quad\defeq\quad&
	\tlang{\not\sqsubseteq}_\amodel
\tag{does not hold}
\\
	\refop{\amodel}{\true}{\mathsf{isObserved}}
\quad\defeq\quad&
	\tlang{\sqsupseteq}_\amodel
\tag{is observed}
\\
	\refop{\amodel}{\false}{\mathsf{isObserved}}
\quad\defeq\quad&
	\tlang{\not\sqsupseteq}_\amodel
\tag{is not observed}
\\
\end{align*}
\end{defn}