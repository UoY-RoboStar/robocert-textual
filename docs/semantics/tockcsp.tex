%!TEX root=../robocert.tex

This section introduces a \tockcsp{} semantics for \langname.
This semantics is inspired by that of Lima et al. on the CML semantics of
UML sequence diagrams~\cite{lima-semantics}.

The behaviour of the \langname{} generator is expected to conform to
this semantics, except that:

\begin{itemize}
\item
  The generator targets \cspm{} instead of CSP, and so \emph{may}
  use semantically equivalent \cspm{} constructs where the CSP equivalents
  are missing or not idiomatic;
\item
  The generator \emph{must} wrap processes in
  timed sections and prioritisations to achieve the appropriate \tockcsp{} behaviours of
  CSP operators;
\item
  The generator \emph{may} perform semantics-preserving optimisations,
  such as substituting \(P\) for \(\tlang{\Stop \interrupt \olang{P}}\).
\end{itemize}

\todo{Some of the definitions are very loosely typed (as they are expanding from
a metamodel to textual snippets of something halfway between \tockcsp{} and
\cspm), and it'd be nice to fix that and/or give explicit result types.}

\subsection{Assertions}

The definitions here correspond to \cref{sec:metamodel-assertions}.

\begin{definition}[\massertion]

\newcommand{\refop}[3]{\arefop_{#1}^{(#2, #3)}}

The semantics of a
\msequenceassertion{} relates the \msequence{} of the assertion to the
\mtarget{} of the assertion.
%
\begin{align*}
	\asstsema{\asasst}
\quad\defeq\quad&
	\seqnameOf{\field{\asasst}{sequence}}
	\;
	\refop{\field{\asasst}{model}}{\field{\asasst}{isNegated}}{\field{\asasst}{type}}
	\;
	\targetsema{\field{\field{\asasst}{sequence}}{target}}{\field{\asasst}{instantiation}}
\end{align*}

The exact refinement operator depends on the assertion type and negation:
%
\begin{align*}
	\refop{\amodel}{\true}{\mathsf{holds}}
\quad\defeq\quad&
	\tlang{\sqsubseteq_{\olang{\amodel}}}
&
	\refop{\amodel}{\false}{\mathsf{holds}}
\quad\defeq\quad&
	\tlang{\not\sqsubseteq_{\olang{\amodel}}}
\\
	\refop{\amodel}{\true}{\mathsf{isObserved}}
\quad\defeq\quad&
	\tlang{\sqsupseteq_{\olang{\amodel}}}
&
	\refop{\amodel}{\false}{\mathsf{isObserved}}
\quad\defeq\quad&
	\tlang{\not\sqsupseteq_{\olang{\amodel}}}
\\
\end{align*}
\end{definition}


\subsection{Sequences}\label{ssec:semantics-tockcsp-sequences}

The definitions here correspond to \cref{sec:metamodel-sequences}.

\begin{definition}[\msequence]

The semantics of a \msequence{} is that of its subsequence
\todo{eventually, in parallel with its memory}.
%
\begin{align*}
	\seqsema{\aseq}
\quad\defeq\quad&	
	\sseqsema{\field{\aseq}{body}}
\end{align*}

\end{definition}

\begin{definition}[\msubsequence]

The semantics of a \msubsequence{} is a sequential composition of that of its steps.
%
\begin{align*}
	\sseqsema{\asseq}
	\quad\defeq\quad&	
	\funcname{steps}(\field{\asseq}{body})
\\
	\funcname{steps}(\langle \astep_1, \dotsc, \astep_n \rangle)
	\quad\defeq\quad&	
	\tlang{
	\olang{\stepsema{\astep_1}}
	\circseq
	\olang{\dotso}
	\circseq
	\olang{\stepsema{\astep_n}}
	}
\end{align*}

\end{definition}

\subsection{Steps}\label{ssec:semantics-tockcsp-steps}

The definitions here correspond to \cref{sec:metamodel-steps}.

\newcommand{\deadline}{\mathbin{\scriptstyle\blacktriangleright}}

\begin{definition}[\msequencestep]
  Case analysis.
  The semantics of a \mactionstep{} consists of an unbounded
  loop over any events allowed by its gap but not by its \msequenceaction,
  interrupted by the action itself.  The exclusion of the events
  offered by the action ensures that the gap cannot nondeterministically
  choose to ignore the action and keep running.
%
\begin{align*}
  \stepsema{\anastep}
  \quad\defeq\quad
  &
    \tlang{
    \runproc{
    \olang{\msgsetsema{\field{\anastep}{gap}}}
    \setminus
    \olang{\eventsOf{\field{\anastep}{action}}}
    }
    \interrupt
    \olang{\actsema{\field{\anastep}{action}}}
    }
    \tag{action step}
  \\
  \intertext{The semantics of a \mdeadlinestep{} is the \emph{deadline} operator
  \(\deadline\) sometimes found in \tockcsp{} literature: the action is
  interrupted after its deadline has expired by a process that prevents any
  further time from passing.
  }
  \stepsema{\adeadline}
  \quad\defeq\quad
  &
    \tlang{
    \sseqsema{\field{\adeadline}{body}}
    \deadline
    \olang{\exprsema{\field{\adeadline}{units}}{\adeadline}}
    }
    \tag{deadline step}
  \\
  x \deadline d
  \quad\defeq\quad
  &
    x \interrupt \funcname{Wait}(d) \circseq \Stop_u
  \\
  \intertext{
  The semantics of a loop is that of the loop
  subsequence hoisted into an auxiliary loop-running process (defined
  below).  \todo{need to add breaking}
  }
  \stepsema{\aloop}
  \quad\defeq\quad
  &
    \funcname{runner}(\field{\aloop}{bound}, \sseqsema{\field{\aloop}{body}})
    \tag{loop step}
  \\
\end{align*}
\end{definition}


\newcommand{\iloop}[1]{\text{Loop}(#1)}
\newcommand{\nloop}[1]{\text{Loop}_\sqcap(#1)}
\newcommand{\dloop}[2]{\text{Loop}_d(#1, #2)}
\newcommand{\lloop}[2]{\text{Loop}_l(#1, #2)}
\newcommand{\uloop}[2]{\text{Loop}_u(#1, #2)}
\newcommand{\rloop}[3]{\text{Loop}_r(#1, #2, #3)}

\begin{definition}[\mloopstep{} runner]
We define the loop-running process as follows:
%
\begin{align*}
  \funcname{runner}(\infty, P)
  \quad\defeq\quad
  & \tlang{\iloop{\olang{P}}}
    \tag{infinite loops}
  \\
  \funcname{runner}(n, P)
  \quad\defeq\quad
  & \tlang{\dloop{\olang{\exprsema{n}{\emptyset}}}{\olang{P}}}
    \tag{definite-bound loops}
  \\
  \funcname{runner}((l, \ast), P)
  \quad\defeq\quad
  & \tlang{\lloop{\olang{\exprsema{l}{\emptyset}}}{\olang{P}}}
    \tag{lower-bound loops}
  \\
  \funcname{runner}((l, u), P)
  \quad\defeq\quad
  & \tlang{\rloop{\olang{\exprsema{l}{\emptyset}}}{\olang{\exprsema{u}{\emptyset}}}{\olang{P}}}
    \tag{range-bound loops}
  \\  
\end{align*}
%
We can define the processes referenced above directly in CSP, as follows:
%
\begin{align*}
  \iloop{P}
  \quad\defeq\quad
  & P \circseq \iloop{P}
    \tag{infinite}
  \\
  \nloop{P}
  \quad\defeq\quad
  & \Skip \sqcap \left(P \circseq \nloop{P}\right)
    \tag{nondeterministic}
  \\  
  \dloop{n}{P}
  \quad\defeq\quad
  & \Skip \triangleleft n \leq 0 \triangleright \left(P \circseq \dloop{n-1}{P}\right)
    \tag{definite}
  \\
  \uloop{n}{P}
  \quad\defeq\quad
  & \Skip \triangleleft n \leq 0 \triangleright \left(\Skip \sqcap \left(P \circseq \uloop{n-1}{P}\right)\right)
    \tag{upper-bound}
  \\
  \lloop{n}{P}
  \quad\defeq\quad
  & \dloop{n}{P} \circseq \nloop{P}
    \tag{lower-bound}
  \\
  \rloop{l}{u}{P}
  \quad\defeq\quad
  & \lloop{l}{P} \circseq \uloop{u - l}{P}
    \tag{range}
  \\
\end{align*}
\end{definition}

\begin{definition}[Action event sets]
  The event set of an arrow action is the event set of its message spec; for
  other actions, the event set is empty.
%
  \begin{align*}
    \eventsOf{\anarrow}
    \quad\defeq\quad
    &
      \emspecsema{\field{\anarrow}{body}}
    &
      \eventsOf{\anaction}
      \quad\defeq\quad
    &
      \tlang{\emptyset}
  \end{align*}
\end{definition}

\subsection{Actions}\label{ssec:semantics-tockcsp-actions}

The definitions here correspond to \cref{sec:metamodel-actions}.

\begin{definition}[\msequenceaction]

\newcommand{\wait}[1]{\text{Wait}\left(#1\right)}
  
The semantics of an arrow action is the semantics of its arrow as a CSP prefix,
prefixing termination.
%
\begin{align*}
  \actsema{\anarrow}
  \quad\defeq\quad
  &
    \tlang{
    \left(
    \olang{\pmspecsema{\anarrow}}
    \then
    \Skip
    \right)
    }
    \tag{arrow action}
  \\
  \intertext{
  The semantics of a wait action is to wait for the amount of time specified by the expression.}
  \actsema{\await}
  \quad\defeq\quad
  &
    \tlang{
    \wait{\olang{\exprsema{\field{\await}{units}}{\await}}}
    }
    \tag{wait action}
  \\
  \intertext{
  The semantics of a final action is to terminate, potentially after an arbitrary amount of time.}
  \actsema{\bot}
  \quad\defeq\quad
  &
    \tlang{
    \mu x \ldotp
    \Skip
    \sqcap
    \left(\text{tock} \circthen \Skip\right)
    }
    \tag{final action}
\end{align*}

\end{definition}

\subsection{Messages}\label{ssec:semantics-tockcsp-messages}

The definitions here correspond to \cref{sec:metamodel-messages}.

\begin{definition}[\mmessageset]

  The semantics of a message set is the universal event set for \muniversemessageset s;
  the expansion of the given \mmessagespec s for \mextensionalmessageset s;
  the semantics of the referred-to set for \mrefmessageset s;
  and the semantics of the referred-to set operator for \mbinarymessageset s.
%
\begin{align*}
  \msgsetsema{\aumsgset}
  \quad\defeq\quad
  &
    \tlang{\events}
    \tag{universe}
  \\
  \intertext{\todo{The meta/object language distinction is messy here
  and I'm not sure how to handle it.}}
  \msgsetsema{\anemsgset}
  \quad\defeq\quad
  &
    \tlang{
    \bigcup
    \olang{
    \Set{
    \emspecsema{\amspec} | \amspec \in \field{\anemsgset}{messages}
    }
    }
    }
    \tag{extensional}
  \\
  \msgsetsema{\armsgset}
  \quad\defeq\quad
  &
    \msgsetsema{\field{\field{\armsgset}{set}}{set}}
    \tag{reference}
  \\
  \msgsetsema{\amsgset_l \odot \amsgset_r}
  \quad\defeq\quad
  &
  \tlang{
    \olang{\msgsetsema{\amsgset_l}}
    \odot
    \olang{\msgsetsema{\amsgset_r}}
    \tag{binary-operator}
  }
\end{align*}
\end{definition}

There are two semantic rules for \mmessagespec s.  One is used whenever
we expand the \mmessagespec{} into an event set, and handles `rest' arguments
by implicitly quantifying over the missing parameters.  The other is used when
expanding to a prefix, and introduces explicit discards for the missing
parameters.  \todo{The two forms will diverge further when we introduce
parameter binding.}

\begin{definition}[\mmessagespec{} as an event set]

We expand \mmessagespec s into event-set form in two stages: expanding
any non-`rest' arguments with \funcname{withArgs}, then expanding the channel
reference using \funcname{msgChan}.
%
\begin{align*}
	\emspecsema{\amspec}
\quad\defeq\quad&
\funcname{withArgs}\left(\field{\amspec}{arguments}, \amspec\right)
\\
	\funcname{withArgs}\left(\amspec, \anarglist\cat\langle\anexprarg\rangle\right)
\quad\defeq\quad&
\tlang{
	\olang{\funcname{withArgs}\left(\amspec, \anarglist\right)}
	!\olang{\exprsema{\anexprarg}{\amspec}}
}
\tag{expression argument}
\\
	\funcname{withArgs}\left(\amspec, \anarglist\cat\langle\arestarg\rangle\right)
\quad\defeq\quad&
	\funcname{withArgs}\left(\amspec, \anarglist\right)
\tag{rest argument}
\\
	\funcname{withArgs}\left(\amspec, \langle\rangle\right)
\quad\defeq\quad&
	\funcname{msgChan}\left(\amspec\right)
\tag{end of arguments}
\end{align*}
The expansion of the message channel
depends on the message topic
and, for certain topics, the direction (inbound from world to target, or
outbound from target to world).
\newcommand{\nsOf}[1]{\mathsf{ns}(#1)}
\newcommand{\topicOf}[2]{\mathsf{topic}(#1,#2)}
%
\begin{align*}
	\funcname{msgChan}(\amspec)
\quad\defeq\quad&
\tlang{
	\olang{\nsOf{\field{\amspec}{target}}}
	{}\cspnsop{}
	\olang{\topicOf{\field{\amspec}{topic}}{\field{\amspec}{direction}}}
}
\\
	\topicOf{\anop}{\texttt{OUTBOUND}}
\quad\defeq\quad&
\tlang{
	\olang{\field{\anop}{name}}\text{Call}
}
\tag{operation; always outbound}
\\
	\topicOf{\anevent}{\texttt{INBOUND}}
\quad\defeq\quad&
	\tlang{\olang{\field{\anevent}{name}}\text{.in}}
\tag{inbound event}
\\
	\topicOf{\anevent}{\texttt{OUTBOUND}}
\quad\defeq\quad&
	\tlang{\olang{\field{\anevent}{name}}\text{.out}}
\tag{outbound event}
\end{align*}
\end{definition}

\newcommand{\paramsOf}[1]{\funcname{params}(#1)}
\newcommand{\beforeRest}[1]{\funcname{beforeRest}(#1)}

\begin{definition}[\mmessagespec{} as a prefix]

To expand a \mmessagespec{} into a prefix, we take the event set expansion and
\todo{for now} \emph{pad} it with wildcard inputs for each topic parameter
left unmatched at the point of any \mrestargument.
%
\begin{align*}
	\pmspecsema{\amspec}
\quad\defeq\quad&
	\funcname{pad}\left(\emspecsema{\amspec}, \funcname{padding}(\amspec)\right)
\\
	\funcname{pad}(x, 0)
\quad\defeq\quad&
	x
\tag{base case}
\\
	\funcname{pad}(x, n)
\quad\defeq\quad&
\tlang{
	\olang{\funcname{pad}(x, n-1)}?\_
}
\tag{inductive case}
\\
	\funcname{padding}(\amspec)
\quad\defeq\quad&
	\#(\paramsOf{\field{\amspec}{topic}}) - \beforeRest{\field{\amspec}{arguments}}
\\
	\beforeRest{\langle\rangle}
\quad\defeq\quad&
	0
\tag{base case}
\\
	\beforeRest{\langle \arestarg \rangle \cat \anarglist}
\quad\defeq\quad&
	0
\tag{rest argument}
\\
	\beforeRest{\langle \anarg \rangle \cat \anarglist}
\quad\defeq\quad&
	1 + \beforeRest{\anarglist}
\tag{non-rest argument}
\end{align*}
\end{definition}

\subsection{Actors}\label{ssec:semantics-tockcsp-actors}

The definitions here correspond to \cref{sec:metamodel-actors}.


\begin{definition}[\mtarget]

The semantics of a target is the parametric process generated for that
target by the relevant external semantics, with constant parameters instantiated
as follows:

\begin{itemize}
\item
	if the constant is bound in the assertion's \mtargetinstantiation{}
	(passed to the semantics as \(\aninst\)), use the bound expression; else
\item
	if the constant is bound in the target's \mtargetinstantiation, use
	the bound expression; else
\item
	use the \(\funcname{constName}\) of the constant, under the assumption
	that it will later bind to a fallback instantiation for the constant.
\end{itemize}
%
\begin{align*}
	\targetsema{\atarget}{\aninst}
\quad\defeq\quad&
\tlang{
	\olang{\funcname{targetProcess}(\atarget)}
	\left(
		\olang{\exprsema{-}{\atarget}\ \circ\ \funcname{instantiate}(\aninst)\ \circ\ \funcname{targetParams}(\atarget)}
	\right)
}
\\
	\funcname{instantiate}(\aninst, \atarget)
\quad\defeq\quad&
	\funcname{constName}
	\oplus
	\field{\field{\atarget}{instantiation}}{constants}
	\oplus
	\field{\aninst}{constants}
\end{align*}
\end{definition}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../robocert"
%%% End:
