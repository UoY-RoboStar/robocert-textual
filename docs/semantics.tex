%!TEX root=./robocert.tex

\newcommand{\tockcsp}{\emph{tock}-CSP}
\newcommand{\cspm}{CSP\(_\text{M}\)}

\newcommand{\interrupt}{\mathbin{\triangle}}
\newcommand{\defeq}{\mathbin{\overset{\text{def}}=}}
\newcommand{\events}{\mathsf{Events}}
% Metasyntactic variables.
\newcommand{\anarrow}{a}
\newcommand{\anevent}{e}
\newcommand{\agap}{g}
\newcommand{\amsgset}{M}
\newcommand{\aname}{n}
\newcommand{\anop}{o}
\newcommand{\asseq}{q}
\newcommand{\astep}{s}
\newcommand{\atarget}{t}
\newcommand{\aworld}{w}
\newcommand{\anaction}{x}
\newcommand{\refto}[1]{#1_r}

\newcommand{\sema}[1]{\llbracket #1 \rrbracket}
\newcommand{\stepsema}[1]{\sema{#1}^{\text{step}}}
\newcommand{\gapsema}[2]{\sema{#1}^{\text{gap}}_{(#2)}}
\newcommand{\actsema}[1]{\sema{#1}^{\text{act}}}
\newcommand{\arrsema}[1]{\sema{#1}^{\text{arr}}}
\newcommand{\loopsema}[2]{\sema{#1}^{\text{loop}}_{(#2)}}
\newcommand{\msgsetsema}[1]{\sema{#1}^{\text{mset}}}
\newcommand{\seqsema}[1]{\sema{#1}^{\text{seq}}}
\newcommand{\sseqsema}[1]{\sema{#1}^{\text{sseq}}}

\newcommand{\eventsof}[1]{\mathsf{eventsOf}(#1)}

This chapter formally captures the semantics of \langname{} in terms of its
target languages:

\begin{itemize}
\item
	\tockcsp;
\item
	\todo{PRISM};
\item
	\todo{Isabelle/UTP?}.
\end{itemize}

\section{\tockcsp{} semantics}

This section introduces a semantics for \langname{} in the form of
rewrite rules from \todo{a canonicalised form of?} the \langname{} textual
syntax to a series of \emph{tock}-CSP processes.
This semantics borrows heavily from that of Lima et al. on the CML semantics of
UML sequence diagrams.

The behaviour of the \langname{} generator is expected to conform to
this semantics, except that:

\begin{itemize}
\item
	The generator targets \cspm{} instead of CSP, and so \emph{may}
	use semantically equivalent \cspm{} constructs where the CSP equivalents
	are missing or not idiomatic;
\item
	The generator \emph{may} \todo{not yet but eventually} wrap processes in
	timed sections to achieve the appropriate \tockcsp{} behaviours of
	CSP operators;
\item
	The generator \emph{may} perform semantics-preserving optimisations,
	such as substituting \(P\) for \(\Stop \interrupt P\).
\end{itemize}

\begin{table}
	\centering

	\begin{tabular}{rl}
	\toprule
	\thead{Variable} & \thead{Meaning}
	\\
	\midrule
	\(\aname\) & name
	\\
	\(\astep\) & step
	\\
	\(\asseq\) & subsequence
	\\
	\(\agap\) & gap
	\\
	\(\anaction\) & action
	\\
	\midrule
	\(\anarrow\) & arrow message spec
	\\
	\(\amsgset\) & gap message set
	\\
	\midrule
	\(\atarget\) & target (eg. module)
	\\
	\(\refto{\atarget}\) & reference to target
	\\
	\(\aworld\) & world
	\\
	\(\refto{\aworld}\) & reference to world
	\\
	\bottomrule
	\end{tabular}

	\caption{Metasyntactic variables.}
	\label{tab:metasyntactic-variables}
\end{table}

\subsection{Sequences}

\begin{defn}[Sequences]

The semantics of a sequence is, for now, that of its subsequence.

This rule does not capture the fact that the target and world definitions
introduce bindings referred to in message specs; for instance,
\lstinline[language=RoboCert]{sequence X for module Mod as M, world as W}
binds \lstinline[language=RoboCert]{M} to the module target,
\lstinline[language=RoboCert]{Mod} to its module, and
\lstinline[language=RoboCert]{W} to the world.
\todo{add target introduction}

\begin{align*}
	\seqsema{\lquote{sequence}\ \aname\ \lquote{for}\ \atarget\ \lquote{,}\ \aworld\ \asseq}
	\quad\defeq\quad&	
	\left(\aname \mathsf{::\!Sequence} = \sseqsema{\asseq}\right)
\end{align*}

\end{defn}

\begin{defn}[Subsequences]

The semantics of a subsequence is a sequential composition of that of its steps.

\begin{align*}
	\sseqsema{\lquote{\{}\ \astep\ \lquote{\}}}
	\quad\defeq\quad&	
	\stepsema{\astep}
	\tag{base}
\\
	\sseqsema{\lquote{\{}\ \astep\ \lquote{then}\ \asseq\ \lquote{\}}}
	\quad\defeq\quad&	
	\stepsema{\astep} \circseq \sseqsema{\lquote{\{}\ \asseq\ \lquote{\}}}
	\tag{inductive}
\end{align*}

\end{defn}

\subsection{Steps}


\begin{defn}[Steps]

The semantics of a step is an unbounded loop over the events of its gap,
interrupted by the action.\footnote{Note that the semantics of the gap depends
on the action.  This is because, as seen in \(\gapsema{\agap}{\anaction}\),
the events on which the action can interrupt the
gap must be removed from the events of the gap to ensure the interrupt has the
expected semantics.}

If no explicit gap is provided, the semantics is equivalent to that of the gap
declaring an empty \emph{allowed} set.

\begin{align*}
	\stepsema{\lquote{anything}\ \agap\ \lquote{until}\ \anaction}
	\quad\defeq\quad&	
	\mathsf{RUN}\left(\gapsema{\agap}{\anaction}\right) \interrupt \actsema{\anaction}
	\tag{explicit gap}
\\
	\stepsema{\anaction}
	\quad\defeq\quad&	
	\stepsema{\lquote{anything in \{\} until}\ \anaction}
	\tag{implicit empty gap}
\end{align*}
\end{defn}

\subsection{Gaps}

\begin{defn}[Gaps]
	The semantics of a gap is the CSP event set corresponding to the
	difference between the \emph{allowed} set,
	and the result of adding any events
	the action following the gap can initially communicate to the
	\emph{forbidden} set.

\begin{align*}
	\gapsema{
	\lquote{in}
	\amsgset_\mathsf{allowed}
	\lquote{except}
	\amsgset_\mathsf{forbidden}
	}{\anaction}
	\quad\defeq\quad&
	\msgsetsema{\amsgset_\mathsf{allowed}}
	\setminus
	\left(\msgsetsema{\amsgset_\mathsf{forbidden}} \cup \eventsof{\anaction}\right)
	\tag{fully explicit}
\\	
\intertext{
	In terms of the concrete syntax, if the
	\emph{allowed} set is not explicitly
	provided, it is assumed to be the universe; if the \emph{forbidden}
	set is not explicitly provided, it is assumed to be the empty set.}
	\gapsema{
	\lquote{except}
	\amsgset_\mathsf{forbidden}
	}{\anaction}
	\quad\defeq\quad&
	\gapsema{
	\lquote{in universe except}
	\ \amsgset_\mathsf{forbidden}
	}{\anaction}
	\tag{implicit \emph{allowed}}
\\	
	\gapsema{
	\lquote{in}
	\amsgset_\mathsf{allowed}
	}{\anaction}
	\quad\defeq\quad&
	\gapsema{
	\lquote{in}
	\ \amsgset_\mathsf{allowed}
	\ \lquote{except \{\}}
	}{\anaction}
	\tag{implicit \emph{forbidden}}
\\	
	\gapsema{
	}{\anaction}
	\quad\defeq\quad&
	\gapsema{
	\lquote{in universe except \{\}}
	}{\anaction}
	\tag{fully implicit}
\end{align*}
\end{defn}

\begin{defn}[Gap message sets]

From \cref{ssec:metamodel-sequences-gaps}, note that gap message sets in the
\emph{allowed} position can be either extensional or universe; we treat both
using the same rule below.

For now, the semantics of an extensional gap message set depends on treating each
message
spec as if it were an arrow message spec.  This will change when arrow and gap
message specs diverge.
\todo{abuse of notation in extensional rule?}

\begin{align*}
	\msgsetsema{\lquote{universe}}
	\quad\defeq\quad&
	\mathsf{Events}
	\tag{universe}
\\
	\msgsetsema{\amsgset}
	\quad\defeq\quad&
	\bigcup_{\anarrow \in \amsgset} \bullet \arrsema{\anarrow}
	\tag{extensional}
\end{align*}
\end{defn}

\begin{defn}[CSP event sets]
For now, the event set of an action is the prefix of an arrow action, or
the empty set for any other actions.  This will change when the prefix becomes
inexpressible as an event set.
\begin{align*}
	\eventsof{\anarrow}
	\quad\defeq\quad&
	\{\arrsema{\anarrow}\}
	\tag{arrow}
\\
	\eventsof{\anaction}
	\quad\defeq\quad&
	\emptyset
	\tag{anything else}
\end{align*}
\end{defn}

\subsection{Actions}

\begin{defn}[Actions]

The semantics of an arrow action is the semantics of its arrow as a CSP prefix,
prefixing termination.  The semantics of a loop delegates to a separate rule
over its label and subsequence.
For now, a final action does not terminate.

\begin{align*}
	\actsema{\anarrow}
	\quad\defeq\quad&
	\left(
	\arrsema{\anarrow}
	\then
	\Skip
	\right)
	\tag{arrow action}
\\
	\actsema{\lquote{loop}\ \aname\ \asseq}
	\quad\defeq\quad&
	\left(
	\loopsema{\asseq}{\aname}
	\right)
	\tag{loop action}
\\
	\actsema{\lquote{end}}
	\quad\defeq\quad&
	\Stop
	\tag{final action}
\end{align*}

\end{defn}

\begin{defn}[Arrows]

The semantics of arrows depends on the topic of their message specs, and, for
certain topics, the direction (inbound from world to target, or outbound from
target to world).  For now, neither operations nor events can have arguments.

\newcommand{\nsof}[1]{\mathsf{ns}(#1)}

Let \(\nsof{\refto{\atarget}}\) be the name of the module, controller, or state machine
referred to by \(\refto{\atarget}\).

\begin{align*}
	\arrsema{\lquote{operation}\ \anop\ \lquote{from}\ \refto{\aworld}\ \lquote{to}\ \refto{\atarget}}
	\quad\defeq\quad&
	\nsof{\refto{\atarget}}::{\anop}\mathsf{Call}
	\tag{operation}
\\
	\arrsema{\lquote{event}\ \anevent\ \lquote{from}\ \refto{\aworld}\ \lquote{to}\ \refto{\atarget}}
	\quad\defeq\quad&
	\nsof{\refto{\atarget}}::{\anevent}.\mathsf{in}
	\tag{inbound event}
\\
	\arrsema{\lquote{event}\ \anevent\ \lquote{from}\ \refto{\atarget}\ \lquote{to}\ \refto{\aworld}}
	\quad\defeq\quad&
	\nsof{\refto{\atarget}}::{\anevent}.\mathsf{out}
	\tag{outbound event}
\end{align*}

\end{defn}

\begin{defn}[Loops]

For now, only infinite loops exist, and their semantics is that of the loop
subsequence placed in a recursive process.

\begin{align*}
	\loopsema{\asseq}{\aname}
	\quad\defeq\quad&
	\circmu \mathsf{LOOP}_\aname \bullet \left(\sseqsema{\asseq} \circseq \mathsf{LOOP}_\aname\right)
	\tag{infinite loop}
\end{align*}

\end{defn}
