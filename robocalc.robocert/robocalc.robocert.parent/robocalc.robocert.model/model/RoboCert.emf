/**
 * Emfatic projection of the RoboCert metamodel.
 *
 * To use this metamodel, translate it into Ecore using the Emfatic toolchain,
 * then use the MWE2 to generate the support code.
 *
 * Authors:
 * - Matt Windsor (@MattWindsor91): initial model
 */
@namespace(uri="http://robocert.robocalc/", prefix="robocert")
@genmodel
	( basePackage="robocalc.robocert.model"
	, modelPluginID="robocalc.robocert.model"
	, modelDirectory="/robocalc.robocert.model/src-gen"
	, editDirectory="/robocalc.robocert.model.edit/src-gen"
	, editorDirectory="/robocalc.robocert.model.editor/src-gen"
	, testsDirectory="/robocalc.robocert.model.tests/src-gen"
	)
package robocert;

import "platform:/resource/circus.robocalc.robochart/model/robochart.ecore";

/* How to read this model:
 *
 * - With the exception of utility classes, the metamodel is structured based
 *   on how things are (or should be) structured in the RoboCert reference
 *   manual, as well as in the Sirius diagrams.
 * - The Sirius diagrams in `representations.aird` are probably a more
 *   approachable introduction to what is going on here.
 */


///////////////////////////////////////////////////////////////////////////////
// UTILITIES
///////////////////////////////////////////////////////////////////////////////

@genmodel(documentation="An element that might be named, but might not be.

This is usually useful for elements where the name adds some syntactic
complexity but enables cross-reference, and so we want to offer a possible
unnamed variant.")
abstract class OptionallyNamedElement {
	@genmodel(documentation="The name (can be null).")
	attr String[0..1] name;
}


///////////////////////////////////////////////////////////////////////////////
// CORE LANGUAGE
///////////////////////////////////////////////////////////////////////////////

@genmodel(documentation="A RoboCert package.")
class CertPackage extends robochart.BasicPackage {
	@genmodel(documentation="Any groups in this package.

Groups form an ordered list because they can lexically depend on things
defined in previous groups.")
	val Group[*]#parent groups;
}

@genmodel(documentation="A group in a RoboCert package.")
abstract class Group extends OptionallyNamedElement {
	@genmodel(documentation="The parent package.")
	ref CertPackage[1]#groups parent;
}

@genmodel(documentation="A group containing specifications.

Specification groups are context sources by virtue of having a target.")
abstract class SpecGroup extends Group, CSPContextSource {
	@genmodel(documentation="The target of this group.")
	ref Target[1] target;
	@genmodel(documentation="The instantiation in effect in this group.")
	val Instantiation[1]#group instantiation;
}

@genmodel(documentation="A specification (which lives in some form of SpecGroup).")
abstract class Specification extends robochart.NamedElement, Process {
	@genmodel(documentation="The variables available for receiving arguments.")
	val robochart.VariableList[1] variables;
}


//
// TARGETS
//

@genmodel(documentation="Group containing one or more specification targets.")
class TargetGroup extends Group {
	@genmodel(documentation="Targets contained in this group.")
	val Target[*]#group targets;
}

@genmodel(documentation="A specification target.

Targets combine several things: a RoboChart element;
a process representing the element from a refinement perspective;
information about the upstream ('context') elements connected to this target;
and information about the downstream elements connected to it.")
abstract class Target extends Process, robochart.NamedElement {
	// TODO(@MattWindsor91): make these OptionallyNamedElements, with the
	// name of the underlying element being the default name.

	@genmodel(documentation="The group to which this target belongs.")
	ref TargetGroup[1]#targets group;
	
	//
	// Derived properties
	//

	// TODO(@MattWindsor91): move parameterisation here?

	@genmodel(documentation="Any elements inside the context of this target.")
	derived volatile transient readonly ref robochart.NamedElement[*] contextElements;

	@genmodel(documentation="Lowest common denominator for the targeted element.")
	derived volatile transient readonly ref robochart.NamedElement[1] element;	
}

//
// Component targets
//

@genmodel(documentation="A target referring to the behaviour of a component.")
abstract class ComponentTarget extends Target {
}

@genmodel(documentation="A target referring to a RoboChart module.

Such a target has the robotic platform as its context and its element is the module.")
class ModuleTarget extends ComponentTarget {
	@genmodel(documentation="The module referred to by this target.")
	ref robochart.RCModule[1] module;
}

@genmodel(documentation="A target referring to a RoboChart controller.")
class ControllerTarget extends ComponentTarget {
	@genmodel(documentation="The controller referred to by this target.")
	ref robochart.ControllerDef[1] controller;
}

@genmodel(documentation="A target referring to a RoboChart state machine.")
class StateMachineTarget extends ComponentTarget {
	@genmodel(documentation="The state machine referred to by this target.")
	ref robochart.StateMachineDef[1] stm;
}

@genmodel(documentation="A target referring to a RoboChart operation.")
class OperationTarget extends ComponentTarget {
	@genmodel(documentation="The operation referred to by this target.")
	ref robochart.OperationDef[1] operation;
}

//
// Collection targets
//

@genmodel(documentation="A target that contains a collection of elements.")
abstract class CollectionTarget extends Target {
	@genmodel(documentation="Any components accessible from this target.")
	derived volatile transient readonly ref robochart.ConnectionNode[*] components;	
}

@genmodel(documentation="A target referring to the contents of a RoboChart module.")
class InModuleTarget extends CollectionTarget {
	@genmodel(documentation="The module referred to by this target.")
	ref robochart.RCModule[1] module;
}

@genmodel(documentation="A target referring to the contents of a RoboChart controller.")
class InControllerTarget extends CollectionTarget {
	@genmodel(documentation="The controller referred to by this target.")
	ref robochart.ControllerDef[1] controller;
}

@genmodel(documentation="Uses the target of a specification group as a process source.

This includes any instantiation for the target parameters.")
class TargetGroupSource extends Process {
	// TODO(@MattWindsor91): this is not a good workaround for the issue of
	// needing to take these things as process sources.
	@genmodel(documentation="The group whose target we are referencing.")
	ref SpecGroup[1] targetGroup;
}

//
// Instantiations
//

@genmodel(documentation="Specifies a (partial) instantiation of targets in a group.")
class Instantiation {
	@genmodel(documentation="The parent group of this instantiation.")
	ref SpecGroup[1]#instantiation group;

	@genmodel(documentation="Any constant assignments.")
	val ConstAssignment[*] assignments;

	@genmodel(documentation="Gets any available instantiation for the constant in this instantiation.")	
	derived readonly transient volatile op robochart.Expression[0..1] getConstant(robochart.Variable constant); 
}

@genmodel(documentation="Assigns a value to one or more constants.")
class ConstAssignment {
	@genmodel(documentation="The constant(s) being assigned.")
	ref robochart.Variable[+] constants;
	
	@genmodel(documentation="The expression containing the new value of the constant(s).")
	val robochart.Expression[1] value;
	
	@genmodel(documentation="Checks whether this assignment maps the given constant.")
	derived readonly transient volatile op boolean[1] hasConstant(robochart.Variable constant);
}

//
// ASSERTIONS
//

@genmodel(documentation="An assertion group.")
class AssertionGroup extends Group {
	val Assertion[*]#group assertions;
}

@genmodel(documentation="An assertion.")
class Assertion extends robochart.NamedElement {
	@genmodel(documentation="The group to which this assertion belongs.")
	ref AssertionGroup[1]#assertions group;

	@genmodel(documentation="The root property of the assertion.")
	val Property[1] property;
}

@genmodel(documentation="A property in an assertion.")
abstract class Property {
	// TODO(@MattWindsor91): we may eventually want conjunctions/disjunctions,
	// in which case I might need to re-evaluate whether negated belongs here.

	@genmodel(documentation="Whether the assertion must fail to hold for the model to be validated.")
	attr boolean[1] negated;
}

//
// Core properties
//

@genmodel(documentation="A core property.")
class CoreProperty extends Property {
	// TODO(@MattWindsor91): it may one day be the case that core properties
	// should accept things other than CSP process sources, eg if we track
	// those properties in other backends, or if we add clock initialised
	// properties.

	@genmodel(documentation="The subject of the property.")
	ref Process[1] subject;
	
	@genmodel(documentation="The specific type of property being investigated.")
	attr CorePropertyType[1] type;
}

@genmodel(documentation="Enumeration of core properties.")
enum CorePropertyType {
	@genmodel(documentation="Timelock freedom.")
	TIMELOCK_FREE;
	@genmodel(documentation="Timed deadlock freedom.")
	DEADLOCK_FREE;
	@genmodel(documentation="Determinism.")
	DETERMINISM;
	@genmodel(documentation="Termination.")
	TERMINATION;
	// TODO(@MattWindsor91): clock initialisation
}

// TODO(@MattWindsor91): binary types

//
// MODALITIES
//

@genmodel(documentation="Temperature modality.")
enum Temperature {
	@genmodel(documentation="Cold temperature; no obligation on model to ensure progress.")
	COLD;
	@genmodel(documentation="Hot temperature; obligation on model to ensure progress.")
	HOT;	
}


///////////////////////////////////////////////////////////////////////////////
// SEQUENCES
///////////////////////////////////////////////////////////////////////////////

@genmodel(documentation="A collection of sequence diagrams.")
class SequenceGroup extends SpecGroup {
	@genmodel(documentation="Any message sets named on the sequence group.")
	!ordered val NamedMessageSet[*]#group messageSets;
	
	@genmodel(documentation="The interactions inside this sequence group.")
	!ordered val Interaction[*]#group interactions;
	
	@genmodel(documentation="The actors available in this sequence group.")
	!ordered val Actor[2..*]#group actors;

	
	//
	// Derived properties
	//

	// NOTE(@MattWindsor91): these derivations have to be on the *group*, not
	// the sequences.  This is because implicit edges in message sets rely on
	// these existing.

	@genmodel(documentation="Shortcut for getting the target actor of the group, if any.")
	derived volatile transient readonly ref TargetActor[0..1] targetActor;
	
	@genmodel(documentation="Shortcut for getting the world of the group, if any.")
	derived volatile transient readonly ref World[0..1] world;
}

@genmodel(documentation="An interaction spawning a sequence diagram.")
class Interaction extends Specification {
	@genmodel(documentation="The group to which this sequence belongs.")
	ref SequenceGroup[1]#interactions group;
	
	@genmodel(documentation="The set of group actors forming lifelines/gates in this diagram.

The order determines that in which lifelines are shown in the graphical notation.")
	ordered ref Actor[2..*] actors;

	@genmodel(documentation="The fragments of the sequence diagram.")
	ordered val InteractionFragment[*] fragments;
}

//
// STEPS
//

// NOTE: When adding new steps, remember to extend the step generators.

@genmodel(documentation="A single interaction fragment in a subsequence.")
abstract class InteractionFragment {
}

//
// Non-combined fragments
//

@genmodel(documentation="An interaction fragment referring to a particular occurrence in time.")
class OccurrenceFragment extends InteractionFragment {
	@genmodel(documentation="The occurrence proper.")
	val Occurrence[1]#fragment occurrence;
	
	@genmodel(documentation="The temperature of this occurrence.")
	attr Temperature[1] temperature;
}

//
// Combined fragments
//

@genmodel(documentation="Abstract class for combined fragments.")
abstract class CombinedFragment extends InteractionFragment, OptionallyNamedElement {
	// TODO(@MattWindsor91): derived property for all subsequences?
}

//
// Block fragments
//

@genmodel(documentation="Combined fragment that contains exactly one body.")
abstract class BlockFragment extends CombinedFragment {
	@genmodel(documentation="The body of the block.")
	val InteractionOperand[1] body;
}

@genmodel(documentation="An optional fragment.")
class OptFragment extends BlockFragment {
	@genmodel(documentation="The temperature of this fragment.

Cold means 'implementation decides whether this fragment is live';
hot means 'implementation must be prepared to engage in both live and dead behaviours'.")
	attr Temperature[1] temperature;
}

@genmodel(documentation="Fragment imposing a duration constraint on a block.")
class DurationFragment extends BlockFragment {
	@genmodel(documentation="Lower bound, in time units after the start of the block.")
	val robochart.Expression[0..1] lowerBound;

	@genmodel(documentation="Upper bound, in time units after the start of the block.")
	val robochart.Expression[0..1] upperBound;
}

@genmodel(documentation="An interaction fragment blocking the diagram until any occurrence happens on the block.

This is an extension to UML.")
class UntilFragment extends BlockFragment {
	@genmodel(documentation="The messages that may occur while waiting for 'body'.")
	val MessageSet[1] intraMessages;
}

@genmodel(documentation="A fragment containing one or more sequence elements in loop.")
class LoopFragment extends BlockFragment {
	@genmodel(documentation="The loop bound.")
	val LoopBound[1] bound;

	// TODO: conditionals
}

//
// Loop bounds
//

@genmodel(documentation="A bound on the number of iterations the loop can make.")
abstract class LoopBound {
}

@genmodel(documentation="A loop bound that makes the loop execute infinitely until otherwise broken.")
class InfiniteLoopBound extends LoopBound {
}

@genmodel(documentation="A loop bound that executes a specific number of times.

Corresponds to UML2 loop(times).")
class DefiniteLoopBound extends LoopBound {
	@genmodel(documentation="The number of times the loop must execute, unless prematurely broken.

Evaluated once only.")
 	val robochart.Expression[1] times;
}

@genmodel(documentation="A loop bound that executes a nondeterministic number of times that is at least a lower bound.

Corresponds to UML2 loop(lowerTimes, *).")
class LowerLoopBound extends LoopBound {
	@genmodel(documentation="Lower number of times the loop must execute, unless prematurely broken.

Evaluated once only.")
 	val robochart.Expression[1] lowerTimes;
}

@genmodel(documentation="A loop bound that executes a nondeterministic number of times between two bounds.

Corresponds to UML2 loop(lowerTimes, upperTimes).")
class RangeLoopBound extends LoopBound {
	@genmodel(documentation="Lower number of times the loop must execute, unless prematurely broken.

Evaluated once only.")
	val robochart.Expression[1] lowerTimes;
	@genmodel(documentation="The upper number of times the loop must execute.

Evaluated once only.")
	val robochart.Expression[1] upperTimes;
}

//
// Branch fragments
//

@genmodel(documentation="Abstract fragment containing two or more branches.")
abstract class BranchFragment extends CombinedFragment {
	@genmodel(documentation="The branches available in this fragment.")
	val InteractionOperand[2..*]#fragment branches;
}

@genmodel(documentation="An alternative choice fragment.")
class AltFragment extends BranchFragment {
	@genmodel(documentation="The temperature of this alternative.")
	attr Temperature[1] temperature;
}

@genmodel(documentation="An interleaving composition fragment.")
class ParFragment extends BranchFragment {
}

@genmodel(documentation="A potentially-guarded subsequence used in a BranchFragment.")
class InteractionOperand {
	@genmodel(documentation="The guard for this operand.")
	val Guard[1]#parent guard;
	
	@genmodel(documentation="The fragments in this operand.")
	ordered val InteractionFragment[*] fragments;
}

@genmodel(documentation="A condition placed on an InteractionOperand.")
abstract class Guard {
	@genmodel(documentation="The parent branch of this guard.")
	ref InteractionOperand[1]#guard parent;
}

@genmodel(documentation="A guard that is always true.")
class EmptyGuard extends Guard {
}

@genmodel(documentation="A guard that is dependent on the truth value of an expression.")
class ExprGuard extends Guard {
	val robochart.Expression[1] expr;
}

@genmodel(documentation="A guard that is true if all other guards in the BranchFragment are false.

It is ill-formed to have multiple ElseGuards in a step, or to have both an
ElseGuard and an EmptyGuard in a step.")
class ElseGuard extends Guard {
}

//
// OCCURRENCES
//

@genmodel(documentation="An occurrence in a sequence.")
abstract class Occurrence {
	@genmodel(documentation="The fragment containing this action.")
	ref OccurrenceFragment[1]#occurrence fragment;
}

@genmodel(documentation="An occurrence that represents a message communication.

Unlike UML, there is only one occurrence for both ends of the message.")
class MessageOccurrence extends Occurrence {
	@genmodel(documentation="The message itself.")
	val Message[1] message;
}

@genmodel(documentation="Base class of occurrences on exactly one lifeline.")
abstract class LifelineOccurrence extends Occurrence {
	@genmodel(documentation="The actor on which this occurrence is occurring.")
	ref Actor[1] actor;	
}

@genmodel(documentation="Represents a deadlock event in a sequence.")
class DeadlockOccurrence extends LifelineOccurrence {
}

@genmodel(documentation="Represents a wait for some amount of time units.")
class WaitOccurrence extends LifelineOccurrence {
	@genmodel(documentation="The number of units to wait.")
	val robochart.Expression[1] units;
	
	// TODO(@MattWindsor91): nondeterministic waits
}

//
// MESSAGES
//

@genmodel(documentation="A specification of a message.")
class Message {
	@genmodel(documentation="The topic of the message.")
	val MessageTopic[1]#message topic;
	
	@genmodel(documentation="The argument list for the message.")
	val ValueSpecification[*] arguments;
	
	@genmodel(documentation="The pair of actors participating in this message.")
	val Edge[1]#spec edge;
}

//
// Edges
//

@genmodel(documentation="A pair of actors referenced by a Message.

There are multiple ways to resolve this pair, and so multiple subclasses of Edge.")
abstract class Edge {
	@genmodel(documentation="The parent Message.")
	ref Message[1]#edge spec;

	//
	// Derived references
	//
	
	@genmodel(documentation="The resolved source of the message.")
	derived transient readonly volatile ref Actor[1] resolvedFrom;
	@genmodel(documentation="The resolved destination of the message.")
	derived transient readonly volatile ref Actor[1] resolvedTo;
}

@genmodel(documentation="An explicit edge.")
class ExplicitEdge extends Edge {
	// TODO(@MattWindsor91): it is unclear whether these should be allowed
	// in bidirectional diagrams, as that raises ambiguity at the graphical
	// notation level.

	@genmodel(documentation="The source of the message.")
	ref Actor[1] from;
	@genmodel(documentation="The destination of the message.")
	ref Actor[1] to;
}

@genmodel(documentation="An edge implied by a direction.

Such edges are only valid when there are two actors in the sequence,
one of the actors is a target, and the other is a world.
They also won't work if the message is not embedded in a sequence group.
")
class ImplicitEdge extends Edge {
	@genmodel(documentation="The direction of the pair.")
	attr EdgeDirection[1] direction = "OUTBOUND";
}

@genmodel(documentation="The direction of an implicit edge.")
enum EdgeDirection {
	@genmodel(documentation="Heading out from target to world.

This is the default when no direction is specified, primarily to accommodate
operations where it is the only allowed direction.")
	OUTBOUND;
	@genmodel(documentation="Heading in from world to target.")
	INBOUND;
}

//
// Message topics
//

@genmodel(documentation="A message topic.")
abstract class MessageTopic {
	@genmodel(documentation="The parent message specification.")
	ref Message[1]#topic message;
	
	//
	// Derived properties
	//
	
	@genmodel(documentation="The types of all parameters accepted by this topic.

For event topics, there is at most one pseudo-parameter: the type of the event.")
	derived transient readonly volatile ref robochart.Type[*] paramTypes;	
}

@genmodel(documentation="An event message topic.")
class EventTopic extends MessageTopic {
	@genmodel(documentation="The name of the event.")
	ref robochart.Event[1] event;
}

@genmodel(documentation="An operation message topic.")
class OperationTopic extends MessageTopic {
	@genmodel(documentation="The name of the operation.")
	ref robochart.OperationSig[1] operation;
}

//
// Message arguments
//

@genmodel(documentation="A value specification.")
abstract class ValueSpecification {
}

@genmodel(documentation="Value specified by an expression.")
class ExpressionValueSpecification extends ValueSpecification {
	@genmodel(documentation="The expression in question.")
	val robochart.Expression[1] expr;
}

@genmodel(documentation="Value left unconstrained (except by type), and possibly bound.")
class WildcardValueSpecification extends ValueSpecification {
	@genmodel(documentation="An optional variable to receive the value.")
	ref robochart.Variable[0..1] destination;
}

//
// Message sets
//

@genmodel(documentation="A defined and named message set.")
class NamedMessageSet extends robochart.NamedElement {
	@genmodel(documentation="The sequence group on which this message set is defined.")
	ref SequenceGroup#messageSets group;

	@genmodel(documentation="The inner message set.")
	val MessageSet[1] set;
}

@genmodel(documentation="A set of message specifications.")
abstract class MessageSet {
	@genmodel(documentation="Whether this message set has messages.

For instance, universal message sets are always active, but extensional ones may be if no messages are held,
reference sets are active iff their referred-to sets are,
and binary message sets depend on the operator and operands.

This is an optimistic estimate, and may falsely report activity when there isn't any.")
	derived volatile readonly transient attr boolean active;
	
	@genmodel(documentation="Whether this message set contains every message.

Universal message sets are always universal,
reference sets are active iff their referred-to sets are,
and binary message sets depend on the operator and operands.

This is a pessimistic estimate, and may falsely deny universality when there is some.")
	derived volatile readonly transient attr boolean universal;	
}

@genmodel(documentation="A message set that is a reference to a previously named message set.")
class RefMessageSet extends MessageSet {
	@genmodel(documentation="The message set being named.")
	ref NamedMessageSet[1] set;
}

@genmodel(documentation="A message set that extensionally enumerates messages.")
class ExtensionalMessageSet extends MessageSet {
	@genmodel(documentation="The message specifications held by this message set.")
	!ordered val Message[*]#set messages;
}

@genmodel(documentation="A message set that includes all messages.")
class UniverseMessageSet extends MessageSet {
}

@genmodel(documentation="A binary set operation over two message sets.")
class BinaryMessageSet extends MessageSet {
	// NOTE(@MattWindsor91): I've tried making this and other classes have
	// a generic binary superclass, but ran into problems with Xtext being
	// unable to deal with the resulting type erasure.
	
	@genmodel(documentation="The left-hand side.")
	val MessageSet[1] lhs;
	
	@genmodel(documentation="The right-hand side.")
	val MessageSet[1] rhs;
	
	@genmodel(documentation="The operator.")
	attr BinarySetOperator[1] operator;
}

@genmodel(documentation="A binary set operator.")
enum BinarySetOperator {
	@genmodel(documentation="Set union ('or').")
	UNION;
	@genmodel(documentation="Set intersection ('and').")
	INTERSECTION;
	@genmodel(documentation="Set difference ('except').")
	DIFFERENCE;
}

//
// ACTORS
//

@genmodel(documentation="An actor in a sequence.

Actors have names, for use in lifelines and ExplicitEdges.")
abstract class Actor extends robochart.NamedElement {
	// NOTE(@MattWindsor91): it would have been more idiomatic to have Actors
	// belong to Sequences rather than SequenceGroups, but MessageSets would
	// need either a complex setup to pick up Actors _or_ would need defining
	// within Sequences.

	@genmodel(documentation="The sequence group to which these actors belong.")
	ref SequenceGroup[1]#actors group;
}

@genmodel(documentation="Actor that stands for the current target.")
class TargetActor extends Actor {
}

@genmodel(documentation="Actor that stands for the environment of the current target.")
class World extends Actor {
}

@genmodel(documentation="Actor that references a component of the target.")
class ComponentActor extends Actor {
	@genmodel(documentation="Component being referenced.

It is ill-formed for this node to not be a component of the target,
and also ill-formed for the same component to form multiple actors.")
	ref robochart.ConnectionNode[1] node;
}


//
// SEQUENCE PROPERTIES
//

@genmodel(documentation="A property of a sequence.")
class SequenceProperty extends Property {
	@genmodel(documentation="Interaction to which this assertion refers.")
	ref Interaction[1] interaction;

	@genmodel(documentation="Type of assertion.")
	attr SequencePropertyType[1] type;
	
	@genmodel(documentation="Model under which this assertion should be checked under CSP.")
	attr CSPModel[1] model = "TICK_TOCK";	
}

@genmodel(documentation="Type of sequence assertion.")
enum SequencePropertyType {
	@genmodel(documentation="All behaviours of the target are included in the sequence.")
	HOLDS;

	@genmodel(documentation="All behaviours of the sequence are observable on the target.")
	IS_OBSERVED;
}


///////////////////////////////////////////////////////////////////////////////
// LOW-LEVEL LANGUAGES
///////////////////////////////////////////////////////////////////////////////

//
// CSP
//

@genmodel(documentation="A group of raw CSP-M declarations.

We generally interpret CSP-M as tock-CSP and implicitly generate it into a
timed section, but this can be overridden.")
class CSPGroup extends SpecGroup {
	@genmodel(documentation="If true, the group should be generated outside of a timed section.")
	attr boolean[1] untimed;
	
	@genmodel(documentation="The fragments contained in this group.")
	val CSPFragment[*]#group fragments;
}

//
// CSP fragments
//

@genmodel(documentation="A fragment of CSP-M.

We generally interpret CSP-M as tock-CSP and implicitly generate it into a
timed section, but this can be overridden.")
abstract class CSPFragment {
	@genmodel(documentation="The raw contents of the CSP fragment.")
	attr String[1] contents;
}

@genmodel(documentation="A fragment of CSP-M that has a name.

These are used to bind CSP-M to names that are referred-to elsewhere.")
class NamedCSPFragment extends CSPFragment, robochart.NamedElement {
}

@genmodel(documentation="A fragment of CSP-M that is bound to an event set.")
class EventSetCSPFragment extends NamedCSPFragment, CSPContextSource {
}

@genmodel(documentation="A fragment of CSP-M that is bound to a process.")
class ProcessCSPFragment extends NamedCSPFragment, Process {
	@genmodel(documentation="The source of the context used for tick-tock model shifting.

We cannot, and do not, check to make sure that this accurately represents
the process's actual event universe.")
	ref CSPContextSource[0..1] events;
}

@genmodel(documentation="A fragment of CSP-M that is not bound to anything.

Such fragments can be named, but don't need to be, and nothing in the semantics
will depend on such a name existing.")
class InlineCSPFragment extends CSPFragment, OptionallyNamedElement {
}

//
// CSP properties
//

@genmodel(documentation="A property that requires a low-level CSP refinement relation.")
class CSPRefinementProperty extends Property {
	@genmodel(documentation="Left-hand side of the refinement.")
	ref Process[1] lhs;

	@genmodel(documentation="Left-hand side of the refinement.")
	ref Process[1] rhs;

	@genmodel(documentation="Type of assertion.")
	attr CSPRefinementOperator[1] type;
	
	@genmodel(documentation="Model under which this assertion should be checked under CSP.")
	attr CSPModel[1] model = "TICK_TOCK";	
}

@genmodel(documentation="A tock-CSP refinement operator.")
enum CSPRefinementOperator {
	@genmodel(documentation="LHS refines RHS.")
	REFINES;

	@genmodel(documentation="LHS refines RHS and RHS refines LHS.")
	EQUALS;
}

@genmodel(documentation="A tock-CSP refinement model.")
enum CSPModel {
	@genmodel(documentation="Tick-tock refinement model.")
	TICK_TOCK;
	
	@genmodel(documentation="Traces refinement model (with prioritisation).")
	TRACES;
}

//
// CSP sources
//

@genmodel(documentation="Abstract class of anything that can be interpreted as a tick-tock context.

This is predominantly a marker, and doesn't hold any state of its own.")
abstract class CSPContextSource {
}

@genmodel(documentation="Abstract class of anything that can be interpreted as a CSP process.

All CSP process sources have an underlying tick-tock context source, even if
it is just the empty set.

This is predominantly a marker, and doesn't hold any state of its own.")
abstract class Process extends CSPContextSource {
}
