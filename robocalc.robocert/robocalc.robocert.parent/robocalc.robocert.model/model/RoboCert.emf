@namespace(uri="http://robocert.robocalc/", prefix="robocert")
@genmodel
	( basePackage="robocalc.robocert.model"
	, modelPluginID="robocalc.robocert.model"
	, modelDirectory="/robocalc.robocert.model/src-gen"
	, editDirectory="/robocalc.robocert.model.edit/src-gen"
	, editorDirectory="/robocalc.robocert.model.editor/src-gen"
	, testsDirectory="/robocalc.robocert.model.tests/src-gen"
	)
package robocert;

import "platform:/resource/circus.robocalc.robochart/model/robochart.ecore";

//
// TOP LEVEL
//

/**
 * A RoboCert package.
 */
class RAPackage extends robochart.BasicPackage {
	/**
	 * Any top-level CSP fragments in this package.
	 * 
	 * TODO: these will likely go away once we have a way of resolving files.
	 */
	val CSPFragment[*] cspFragments;
	/**
	 * Any sequence groups in this package.
	 */
	val SequenceGroup[*] sequenceGroups;
	/**
	 * Any assertions in this package.
	 */
	val Assertion[*] assertions;
}

/**
 * A fragment of CSP-M.
 */
class CSPFragment {
	/**
	 * The raw contents of the CSP fragment.
	 */
	attr String[1] contents;
}

//
// SEQUENCES
//

/**
 * A collection of sequence diagrams between a given target and world.
 */
class SequenceGroup extends robochart.NamedElement {
	/**
	 * The target actor of the sequence group.
	 */
	val Target[1]#group target;
	/**
	 * The world actor of the sequence group.
	 */
	val World[1]#group world;
	/**
	 * Any message sets named on the sequence group.
	 */
	val NamedMessageSet[*]#group messageSets;	
	/**
	 * The sequences inside this sequence group.
	 */
	val Sequence[*]#group sequences;
	/**
	 * Picks up both actors of the sequence diagram.
	 */
	derived volatile transient readonly ref Actor[2] actors;
}

/**
 * A sequence diagram.
 *
 * Well-formed sequence diagrams end with a final or infinite loop action.
 */
class Sequence extends robochart.NamedElement {
	/**
	 * The group to which this sequence belongs.
	 */
	ref SequenceGroup[1]#sequences group;
	/**
	 * The top-level subsequence of the sequence diagram.
	 */
	val Subsequence[1] body;

	//
	// Derived properties
	//

	/**
	 * Picks up the target of this sequence diagram.
	 */
	derived volatile transient readonly ref Target[1] target;
	/**
	 * Picks up the world of this sequence diagram.
	 */
	derived volatile transient readonly ref World[1] world;
	/**
	 * Picks up both actors of the sequence diagram.
	 */
	derived volatile transient readonly ref Actor[2] actors;
}

/**
 * A sequence of steps, forming part or all of a sequence diagram.
 */
class Subsequence {
	/**
	 * The steps contained within the subsequence.
	 * There is always at least one step.
	 */
	val SequenceStep[+]#parent steps;
	
	/**
	 * The parent sequence.
	 */
	derived volatile transient readonly ref Sequence[0..1] sequence;
}

/**
 * A single step in a subsequence.
 */
abstract class SequenceStep {
	/**
	 * The parent subsequence of this step.
	 */
	ref Subsequence[1]#steps parent;
}

/**
 * A sequence step containing a primitive action.
 */
class ActionStep extends SequenceStep {
	/**
	 * The specification of what can happen in the 'gap' before the action.
	 */
	val MessageSet[1] gap;

	/**
	 * The action proper.
	 */
	val SequenceAction[1]#step action;
}

/**
 * A defined and named message set.
 */
class NamedMessageSet extends robochart.NamedElement {
	/**
	 * The sequence group on which this message set is defined.
	 */
	ref SequenceGroup#messageSets group;

	/**
	 * The inner message set.
	 */
	val MessageSet[1] set;
}

/**
 * A set of gap message specifications.
 */
abstract class MessageSet {
	/**
	 * Whether this message set has messages.
	 *
	 * For instance, universal message sets are always active, but
	 * extensional ones may be if no messages are held,
	 * reference sets are active iff their referred-to sets are,
	 * and binary message sets depend on the operator and operands.
	 *
	 * This is an optimistic estimate, and may falsely report activity
	 * when there isn't any.
	 */
	derived volatile readonly transient attr boolean active;
	
	/**
	 * Whether this message set contains every message.
	 *
	 * Universal message sets are always universal,
	 * reference sets are active iff their referred-to sets are,
	 * and binary message sets depend on the operator and operands.
	 *
	 * This is a pessimistic estimate, and may falsely deny universality
	 * when there is some.
	 */
	derived volatile readonly transient attr boolean universal;	
}

/**
 * A message set that is, itself, a reference to a previously named message
 * set.
 */
class RefMessageSet extends MessageSet {
	/**
	 * The message set being named.
	 */
	ref NamedMessageSet[1] set;
}

/**
 * A message set that extensionally enumerates allowed or forbidden messages.
 */
class ExtensionalMessageSet extends MessageSet {
	/**
	 * The message specifications held by this message set.
	 */
	!ordered val GapMessageSpec[*]#parent messages;
}

/**
 * A message set that includes all messages.
 */
class UniverseMessageSet extends MessageSet {
}

/**
 * A message set that is the result of applying a binary operator to two other
 * message sets.
 */
class BinaryMessageSet extends MessageSet {
	/**
	 * The left-hand side.
	 */
	val MessageSet[1] lhs;
	/**
	 * The set operator.
	 */
	attr BinarySetOperator[1] operator;
	/**
	 * The right-hand side.
	 */
	val MessageSet[1] rhs;
}

/**
 * A binary set operator.
 */
enum BinarySetOperator {
	/**
	 * Set union ('or').
	 */
	UNION;
	/**
	 * Set intersection ('and').
	 */
	INTERSECTION;
	/**
	 * Set difference ('except').
	 */
	DIFFERENCE;
}

//
// ACTORS
//

/**
 * An actor in a sequence.
 *
 * There are two actors in a sequence: the 'target' of the sequence,
 * which is the system under test; and the 'world', which is the sum of
 * everything connected to the target.  They are bound to names used in the
 * diagram itself, but the target may also name an external RoboChart entity.
 */
abstract class Actor {
	/**
	 * Typically expands to the target's sequence group parameter.
	 */
	derived volatile transient readonly ref SequenceGroup[0..1] anyGroup;
}

/**
 * The world of a sequence.
 */
class World extends Actor {
	/**
	 * The sequence group to which this actor is attached.
	 */
	ref SequenceGroup[1]#world group;
}

/**
 * A target of a sequence.
 */
abstract class Target extends Actor {
	/**
	 * The sequence group to which this actor is attached.
	 */
	ref SequenceGroup[1]#target group;
	
	/**
	 * An initial instantiation to be applied to the target.
	 * Assertions may apply a further instantiation.
	 */
	val TargetInstantiation[1] instantiation;
}

/**
 * A sequence target referring to a RoboChart module.
 */
class RCModuleTarget extends Target {
	ref robochart.RCModule[1] module;
}

/**
 * Specifies a (partial) instantiation of a target.
 */
class TargetInstantiation {
	/**
	 * Any constant overrides.
	 */
	val ConstAssignment[*] constants;
}

/**
 * A constant override.
 */
class ConstAssignment {
	// NOTE: this would ideally be a Map.Entry, but I couldn't get
	// Xtend's serializer code generator to work with EMaps. 

	/**
	 * The constant being assigned.
	 */
	ref robochart.Variable[1] key;
	/**
	 * The expression containing the new value of the constant.
	 */
	val robochart.Expression[1] value;
}

//
// CONTROL FLOW
//

/**
 * A sequence step that contains exactly one body.
 *
 * Often, but not always, these will be (what UML would call) combined
 * fragments.
 */
abstract class StepWithBody extends SequenceStep {
	/**
	 * The body of the action.
	 */
	val Subsequence[1] body;
}

/**
 * A step containing one or more sequence elements alongside a deadline
 * for all of those elements to terminate, expressed in time units.
 */
class DeadlineStep extends robochart.NamedElement, StepWithBody {
	/**
	 * The deadline, expressed as a number of time units after the start of the
	 * block.
	 */
	val robochart.Expression[1] units;
}

/**
 * A step containing one or more sequence elements in loop.
 *
 * A loop action has a name; this is used both in its semantic elaboration and
 * also as a target for any break actions.
 */
class LoopStep extends robochart.NamedElement, StepWithBody {
	/**
	 * The loop bound.
	 */
	val LoopBound[1] bound;

	// TODO: conditionals
	// TODO: break
}

/**
 * A bound on the number of iterations the loop can make.
 */
abstract class LoopBound {
}

/**
 * A loop bound that makes the loop execute infinitely until otherwise
 * broken.
 */
class InfiniteLoopBound extends LoopBound {
}

/**
 * A loop bound that executes a specific number of times.
 *
 * Corresponds to UML2 loop(times).
 */
class DefiniteLoopBound extends LoopBound {
	/**
	 * The number of times the loop must execute, unless prematurely
	 * broken.
	 * Evaluated once only.
	 */
 	val robochart.Expression[1] times;
}

/**
 * A loop bound that executes a nondeterministic number of times that
 * is at least a lower bound.
 *
 * Corresponds to UML2 loop(lowerTimes, *).
 */
class LowerLoopBound extends LoopBound {
	/**
	 * The number of times the loop must execute at least, unless
	 * prematurely broken.
	 * Evaluated once only.
	 */
 	val robochart.Expression[1] lowerTimes;
}

/**
 * A loop bound that executes a nondeterministic number of times between
 * two bounds.
 *
 * Corresponds to UML2 loop(lowerTimes, upperTimes).
 */
class RangeLoopBound extends LoopBound {
	/**
	 * The lower number of times the loop must execute, unless
	 * prematurely broken.
	 * Evaluated once only.	 
	 */
	val robochart.Expression[1] lowerTimes;
	/**
	 * The upper number of times the loop must execute.
	 * Evaluated once only.
	 */
	val robochart.Expression[1] upperTimes;
}


//
// ACTIONS
//

/**
 * An action in a sequence diagram.
 */
abstract class SequenceAction {
	/**
	 * The step containing this action.
	 */
	ref ActionStep[1]#action step;
}

/**
 * A communicating action in a sequence diagram.
 */
class ArrowAction extends SequenceAction {
	/**
	 * The body of the arrow.
	 */
	val ArrowMessageSpec[1]#parent body;
}

/**
 * A special action marking the end of a diagram.
 *
 * This exists mainly to allow a sequence gap at the end of the diagram.
 */
class FinalAction extends SequenceAction {
}

/**
 * An action representing a wait for some amount of time units.
 */
class WaitAction extends SequenceAction {
	/**
	 * The number of units to wait.
	 */
	val robochart.Expression[1] units;
	
	// TODO(@MattWindsor91): nondeterministic waits
}

//
// MESSAGES
//

/**
 * A specification of a message.
 */
abstract class MessageSpec {
	/**
	 * The topic of the message.
	 */
	val MessageTopic[1]#spec topic;
	
	/**
	 * The direction of the message.
	 */
	attr MessageDirection[1] direction = "OUTBOUND";
	
	//
	// Derived references
	//
	//
	
	/**
	 * The target of the message.
	 *
	 * If the message is outbound, this will be the 'from' of the message;
	 * else, the 'to'.
	 */
	derived transient readonly volatile ref Target[1] target;
	
	/**
	 * The source of the message.
	 */
	derived transient readonly volatile ref Actor[1] from;
	/**
	 * The destination of the message.
	 */
	derived transient readonly volatile ref Actor[1] to;
}

/**
 * A message specification corresponding to an arrow on a sequence diagram.
 */
class ArrowMessageSpec extends MessageSpec {
	/**
	 * The parent of the arrow.
	 */
	ref ArrowAction[1]#body parent;
	
	/**
	 * The argument list for the message.
	 */
	val Argument[*] arguments;
}

/**
 * A message specification corresponding to an entry in a gap list.
 */
class GapMessageSpec extends MessageSpec {
	/**
	 * The parent message set.
	 */
	ref ExtensionalMessageSet[1]#messages parent;
	
	/**
	 * The argument list for the message.  Cannot bind.
	 */
	val NonBindingArgument[*] arguments;
}

/**
 * A message topic.
 */
abstract class MessageTopic {
	/**
	 * The parent message specification.
	 */
	ref MessageSpec[1]#topic spec;
}

/**
 * An event message topic.
 */
class EventTopic extends MessageTopic {
	/**
	 * The name of the event.
	 */
	ref robochart.Event[1] event;
}

/**
 * An operation message topic.
 */
class OperationTopic extends MessageTopic {
	/**
	 * The name of the operation.
	 */
	ref robochart.OperationSig[1] operation;
// TODO: check whether this should be Operation instead
// TODO: parameters
}

/**
 * The direction of a message.
 */
enum MessageDirection {
	/**
	 * Heading in from world to target.
	 */
	INBOUND;
	/**
	 * Heading out from target to world.
	 */
	OUTBOUND;
}

/**
 * An argument pattern.
 */
abstract class Argument {
}

/**
 * An argument pattern that doesn't make any bindings.
 *
 * Only non-binding arguments can appear in gaps.
 */
abstract class NonBindingArgument extends Argument {
}

/**
 * An argument pattern specifying an expression.
 */
class ExpressionArgument extends NonBindingArgument {
	/**
	 * The expression in question.
	 */
	val robochart.Expression[1] expr;
}

/**
 * An argument pattern specifying that all following arguments are unbound.
 */ 
class RestArgument extends NonBindingArgument {
}

//
// ASSERTIONS
//

/**
 * An assertion.
 */
abstract class Assertion extends robochart.NamedElement {
}

/**
 * A RoboCert sequence assertion body.
 */
class SequenceAssertion extends Assertion {
	/**
	 * The sequence to which this assertion refers.
	 */
	ref Sequence[1] sequence;
	/**
	 * Whether the assertion must fail to hold for the model to be validated.
	 */
	attr boolean[1] isNegated;
	/**
	 * The type of assertion.
	 */
	attr SequenceAssertionType[1] type;
	/**
	 * Assertion-level instantiation applied to this sequence's target.
	 */
	val TargetInstantiation[1] instantiation;
	/**
	 * The model under which this assertion should be checked under CSP.
	 * 
	 * TODO(@MattWindsor91): timed models, work out what to do with this actually.
	 */
	attr CSPModel[1] model = "TICK_TOCK";	
}

/**
 * Types of sequence assertion.
 */
enum SequenceAssertionType {
	/**
	 * The sequence holds over the target
	 * (all behaviours of the target are included in the sequence).
	 */
	HOLDS;
	/**
	 * The sequence is observed on the target
	 * (all behaviours of the sequence are observable on the target).
	 */
	IS_OBSERVED;
}

/**
 * A CSP refinement model.
 */
enum CSPModel {
	/**
	 * The timed tick-tock CSP model.
	 */
	TICK_TOCK;
	/**
	 * Traces refinement.
	 */
	TRACES;
}