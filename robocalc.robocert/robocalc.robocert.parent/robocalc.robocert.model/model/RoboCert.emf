/**
 * Emfatic projection of the RoboCert metamodel.
 *
 * To use this metamodel, translate it into Ecore using the Emfatic toolchain,
 * then use the MWE2 to generate the support code.
 *
 * Authors:
 * - Matt Windsor (@MattWindsor91): initial model
 */
@namespace(uri="http://robocert.robocalc/", prefix="robocert")
@genmodel
	( basePackage="robocalc.robocert.model"
	, modelPluginID="robocalc.robocert.model"
	, modelDirectory="/robocalc.robocert.model/src-gen"
	, editDirectory="/robocalc.robocert.model.edit/src-gen"
	, editorDirectory="/robocalc.robocert.model.editor/src-gen"
	, testsDirectory="/robocalc.robocert.model.tests/src-gen"
	)
package robocert;

import "platform:/resource/circus.robocalc.robochart/model/robochart.ecore";

/* How to read this model:
 *
 * - With the exception of utility classes, the metamodel is structured based
 *   on how things are (or should be) structured in the RoboCert reference
 *   manual, as well as in the Sirius diagrams..
 * - The Sirius diagrams in `representations.aird` are probably a more
 *   approachable introduction to what is going on here.
 */

// TODO(@MattWindsor91): port all documentation from doc comments to genmodel


///////////////////////////////////////////////////////////////////////////////
// UTILITIES
///////////////////////////////////////////////////////////////////////////////

@genmodel(documentation="An element that might be named, but might not be.

This is usually useful for elements where the name adds some syntactic
complexity but enables cross-reference, and so we want to offer a possible
unnamed variant.")
abstract class OptionallyNamedElement {
	@genmodel(documentation="The name (can be null).")
	attr String[0..1] name;
}


///////////////////////////////////////////////////////////////////////////////
// CORE LANGUAGE
///////////////////////////////////////////////////////////////////////////////

@genmodel(documentation="A RoboCert package.")
class CertPackage extends robochart.BasicPackage {
	@genmodel(documentation="Any groups in this package.

Groups form an ordered list because they can lexically depend on things
defined in previous groups.")
	val Group[*]#parent groups;
}

@genmodel(documentation="A group in a RoboCert package.

Groups contain specifications in a particular RoboCert notation, instantiating
various constants.")
abstract class Group {
	@genmodel(documentation="The parent package.")
	ref CertPackage[1]#groups parent;
	
	@genmodel(documentation="The instantiation in effect in this group.")
	val Instantiation[1]#group instantiation;
}

//
// INSTANTIATIONS
//

@genmodel(documentation="Specifies a (partial) instantiation of targets in a group.")
class Instantiation {
	@genmodel(documentation="The parent group of this instantiation.")
	ref Group[1]#instantiation group;

	@genmodel(documentation="Any constant assignments.")
	val ConstAssignment[*] assignments;

	@genmodel(documentation="Gets any available instantiation for the constant in this instantiation.")	
	derived readonly transient volatile op CertExpr[0..1] getConstant(robochart.Variable constant); 
}

@genmodel(documentation="Assigns a value to one or more constants.")
class ConstAssignment {
	@genmodel(documentation="The constant(s) being assigned.")
	ref robochart.Variable[+] constants;
	
	@genmodel(documentation="The expression containing the new value of the constant(s).")
	val CertExpr[1] value;
	
	@genmodel(documentation="Checks whether this assignment maps the given constant.")
	derived readonly transient volatile op boolean[1] hasConstant(robochart.Variable constant);
}

//
// ASSERTIONS
//

@genmodel(documentation="An assertion group.")
class AssertionGroup extends Group, OptionallyNamedElement {
	val Assertion[*]#group assertions;
}

@genmodel(documentation="An assertion.")
class Assertion extends robochart.NamedElement {
	@genmodel(documentation="The group to which this assertion belongs.")
	ref AssertionGroup[1]#assertions group;

	@genmodel(documentation="The root property of the assertion.")
	val Property[1] property;
}

@genmodel(documentation="A property in an assertion.")
abstract class Property {
	// TODO(@MattWindsor91): we may eventually want conjunctions/disjunctions,
	// in which case I might need to re-evaluate whether isNegated belongs here.

	@genmodel(documentation="Whether the assertion must fail to hold for the model to be validated.")
	attr boolean[1] isNegated;
}

//
// EXPRESSIONS
//
// Generally, operator expressions are grouped into equivalence classes based
// on similar semantic function and wellformedness conditions; for instance,
// the relational operators are all in the same class.  This differs from
// RoboChart, so it might change later.
//

@genmodel(documentation="A RoboCert expression.")
abstract class CertExpr {
}

//
// Literals
//

@genmodel(documentation="A RoboCert Boolean literal.")
class BoolExpr extends CertExpr {
	@genmodel(documentation="The truth value of the expression.")
	attr boolean[1] truth;
}

@genmodel(documentation="A RoboCert integer literal.")
class IntExpr extends CertExpr {
	@genmodel(documentation="The value of the expression.")
	attr int[1] value;
}

//
// Unary operations
//

@genmodel(documentation="An expression that inverts the sign of another (arithmetic) expression.")
class MinusExpr extends CertExpr {
	// NOTE(@MattWindsor91): if there is ever a compelling reason to add more
	// arithmetic unary operators, this should generalise to fit all of them.

	@genmodel(documentation="The expression to modify.")
	val CertExpr[1] expr; 
}

//
// Binary operations
//

@genmodel(documentation="A binary expression.")
abstract class BinaryExpr extends CertExpr {
	// NOTE(@MattWindsor91): I've tried making this and other classes have
	// a generic binary superclass, but ran into problems with Xtext being
	// unable to deal with the resulting type erasure.

	@genmodel(documentation="The left-hand side.")
	val CertExpr[1] lhs;
	
	@genmodel(documentation="The right-hand side.")
	val CertExpr[1] rhs;	
}

@genmodel(documentation="A logical binary expression.")
class LogicalExpr extends BinaryExpr {	
	@genmodel(documentation="The operator.")
	attr LogicalOperator[1] operator;
}

@genmodel(documentation="A logical operator.")
enum LogicalOperator {
	@genmodel(documentation="Logical conjunction.")
	AND;
	@genmodel(documentation="Logical disjunction.")
	OR;
}

@genmodel(documentation="A relational binary expression.")
class RelationExpr extends BinaryExpr {
	// TODO(@MattWindsor91): consider splitting </<=/>=/> and ==/!=, as
	// they have different wellformedness conditions (eg, the former requires
	// arithmetic types).
	
	@genmodel(documentation="The operator.")
	attr RelationOperator[1] operator;
}

@genmodel(documentation="A relational operator.")
enum RelationOperator {
	@genmodel(documentation="Greater than.")
	GT;
	@genmodel(documentation="Greater than or equal.")
	GE;
	@genmodel(documentation="Equal.")
	EQ;
	@genmodel(documentation="Not equal.")
	NE;
	@genmodel(documentation="Greater than or equal.")
	LE;
	@genmodel(documentation="Less than.")
	LT;
}

//
// Variables
//

@genmodel(documentation="A reference to a constant in the model.")
class ConstExpr extends CertExpr {
	@genmodel(documentation="The constant being referenced.")
	ref robochart.Variable[1] constant;
}

@genmodel(documentation="A reference to a previously-bound RoboCert variable.")
class BindingExpr extends CertExpr {
	@genmodel(documentation="The source of the variable being bound.") 
	ref Binding[1] source;

	// We could track a bidirectional reference here, but Xtext doesn't like it.
}

@genmodel(documentation="A binding point.")
class Binding extends robochart.NamedElement {
}

//
// MODALITIES
//

@genmodel(documentation="Temperature modality.")
enum Temperature {
	@genmodel(documentation="Cold temperature; no obligation on model to ensure progress.")
	COLD;
	@genmodel(documentation="Hot temperature; obligation on model to ensure progress.")
	HOT;	
}


///////////////////////////////////////////////////////////////////////////////
// SEQUENCES
///////////////////////////////////////////////////////////////////////////////

/**
 * A collection of sequence diagrams between a given target and world.
 */
class SequenceGroup extends Group, robochart.NamedElement {
	/**
	 * The target actor of the sequence group.
	 */
	val Target[1]#group target;
	/**
	 * The world actor of the sequence group.
	 */
	val World[1]#group world;
	/**
	 * Any message sets named on the sequence group.
	 */
	val NamedMessageSet[*]#group messageSets;	
	/**
	 * The sequences inside this sequence group.
	 */
	val Sequence[*]#group sequences;
	/**
	 * Picks up both actors of the sequence diagram.
	 */
	derived volatile transient readonly ref Actor[2] actors;
}

@genmodel(documentation="A sequence diagram.")
class Sequence extends robochart.NamedElement, CSPProcessSource {
	/**
	 * The group to which this sequence belongs.
	 */
	ref SequenceGroup[1]#sequences group;
	/**
	 * The top-level subsequence of the sequence diagram.
	 */
	val Subsequence[1] body;

	//
	// Derived properties
	//

	/**
	 * Picks up the target of this sequence diagram.
	 */
	derived volatile transient readonly ref Target[1] target;
	/**
	 * Picks up the world of this sequence diagram.
	 */
	derived volatile transient readonly ref World[1] world;
	/**
	 * Picks up both actors of the sequence diagram.
	 */
	derived volatile transient readonly ref Actor[2] actors;
}

/**
 * A sequence of steps, forming part or all of a sequence diagram.
 */
class Subsequence {
	@genmodel(documentation="The steps contained within the subsequence.")
	val SequenceStep[*]#parent steps;
	
	/**
	 * The parent sequence.
	 */
	derived volatile transient readonly ref Sequence[0..1] sequence;
}

//
// STEPS
//

// NOTE: When adding new steps, remember to extend the step generators.

/**
 * A single step in a subsequence.
 */
abstract class SequenceStep {
	/**
	 * The parent subsequence of this step.
	 */
	ref Subsequence[1]#steps parent;
}

//
// Non-block steps
//

@genmodel(documentation="A sequence step containing a primitive action.")
class ActionStep extends SequenceStep {
	@genmodel(documentation="The specification of what can happen in the 'gap' before the action.")
	val MessageSet[1] gap;

	@genmodel(documentation="The action proper.")
	val SequenceAction[1]#step action;
	
	@genmodel(documentation="The temperature of this action.")
	attr Temperature[1] temperature;
}

//
// Block steps
//

@genmodel(documentation="Step that contains exactly one body.

Often, but not always, these will be (what UML would call) combined
fragments.

Block steps can optionally have a name, which allows breaking.")
abstract class BlockStep extends SequenceStep, OptionallyNamedElement {
	@genmodel(documentation="The body of the block.")
	val Subsequence[1] body;
}

@genmodel(documentation="Step imposing a termination deadline on a block.")
class DeadlineStep extends BlockStep {
	@genmodel(documentation="Deadline, in time units after the start of the block.")
	val CertExpr[1] units;
}

@genmodel(documentation="A step containing one or more sequence elements in loop.")
class LoopStep extends BlockStep {
	@genmodel(documentation="The loop bound.")
	val LoopBound[1] bound;

	// TODO: conditionals
}

//
// Loop bounds
//

/**
 * A bound on the number of iterations the loop can make.
 */
abstract class LoopBound {
}

/**
 * A loop bound that makes the loop execute infinitely until otherwise
 * broken.
 */
class InfiniteLoopBound extends LoopBound {
}

/**
 * A loop bound that executes a specific number of times.
 *
 * Corresponds to UML2 loop(times).
 */
class DefiniteLoopBound extends LoopBound {
	/**
	 * The number of times the loop must execute, unless prematurely
	 * broken.
	 * Evaluated once only.
	 */
 	val CertExpr[1] times;
}

/**
 * A loop bound that executes a nondeterministic number of times that
 * is at least a lower bound.
 *
 * Corresponds to UML2 loop(lowerTimes, *).
 */
class LowerLoopBound extends LoopBound {
	/**
	 * The number of times the loop must execute at least, unless
	 * prematurely broken.
	 * Evaluated once only.
	 */
 	val CertExpr[1] lowerTimes;
}

/**
 * A loop bound that executes a nondeterministic number of times between
 * two bounds.
 *
 * Corresponds to UML2 loop(lowerTimes, upperTimes).
 */
class RangeLoopBound extends LoopBound {
	/**
	 * The lower number of times the loop must execute, unless
	 * prematurely broken.
	 * Evaluated once only.	 
	 */
	val CertExpr[1] lowerTimes;
	/**
	 * The upper number of times the loop must execute.
	 * Evaluated once only.
	 */
	val CertExpr[1] upperTimes;
}

//
// Branch steps
//

@genmodel(documentation="Abstract step containing two or more branches.")
abstract class BranchStep extends SequenceStep {
	@genmodel(documentation="The branches available in this step.")
	val Branch[2..*]#parent branches;
}

@genmodel(documentation="An alternative choice step.")
class AlternativeStep extends BranchStep {
	@genmodel(documentation="The temperature of this alternative.")
	attr Temperature[1] temperature;
}

@genmodel(documentation="An interleaving composition step.")
class InterleaveStep extends BranchStep {
}

@genmodel(documentation="A potentially-guarded subsequence used in a BranchStep.")
class Branch {
	@genmodel(documentation="The guard for this branch.")
	val Guard[1]#parent guard;
	
	@genmodel(documentation="The body of this branch.")
	val Subsequence[1] body;
	
	// This mainly exists to allow us to (eventually) set up ElseGuards,
	// which require us to traverse up to the Branch, enumerate all the
	// expressions, and negate them.
	@genmodel(documentation="The parent step containing this branch (along with others).")
	ref BranchStep[1]#branches parent;
}

@genmodel(documentation="A condition placed on a Branch.")
abstract class Guard {
	@genmodel(documentation="The parent branch of this guard.")
	ref Branch[1]#guard parent;
}

@genmodel(documentation="A guard that is always true.")
class EmptyGuard extends Guard {
}

@genmodel(documentation="A guard that is dependent on the truth value of an expression.")
class ExprGuard extends Guard {
	val CertExpr[1] expr;
}

@genmodel(documentation="A guard that is true if all other guards in the BranchStep are false.

It is ill-formed to have multiple ElseGuards in a step, or to have both an
ElseGuard and an EmptyGuard in a step.")
class ElseGuard extends Guard {
}

//
// ACTIONS
//

/**
 * An action in a sequence diagram.
 */
abstract class SequenceAction {
	/**
	 * The step containing this action.
	 */
	ref ActionStep[1]#action step;
}

/**
 * A communicating action in a sequence diagram.
 */
class ArrowAction extends SequenceAction {
	/**
	 * The body of the arrow.
	 */
	val MessageSpec[1] body;
}

/**
 * A special action marking the end of a diagram.
 *
 * This exists mainly to allow a sequence gap at the end of the diagram.
 */
class FinalAction extends SequenceAction {
}

/**
 * An action representing a wait for some amount of time units.
 */
class WaitAction extends SequenceAction {
	/**
	 * The number of units to wait.
	 */
	val CertExpr[1] units;
	
	// TODO(@MattWindsor91): nondeterministic waits
}

//
// MESSAGES
//

/**
 * A specification of a message.
 */
class MessageSpec {
	/**
	 * The topic of the message.
	 */
	val MessageTopic[1]#spec topic;
	
	/**
	 * The direction of the message.
	 */
	attr MessageDirection[1] direction = "OUTBOUND";
	
	/**
	 * The argument list for the message.
	 */
	val Argument[*] arguments;
	
	//
	// Derived references
	//
	// Most of these come from walking backwards up a MessageSpec to its
	// enclosing SequenceGroup, and won't work if a MessageSpec isn't
	// contained in one.
	//
	
	/**
	 * The target of the message.
	 *
	 * If the message is outbound, this will be the 'from' of the message;
	 * else, the 'to'.
	 */
	derived transient readonly volatile ref Target[1] target;
	
	/**
	 * The source of the message.
	 */
	derived transient readonly volatile ref Actor[1] from;
	/**
	 * The destination of the message.
	 */
	derived transient readonly volatile ref Actor[1] to;
}

/**
 * The direction of a message.
 */
enum MessageDirection {
	/**
	 * Heading in from world to target.
	 */
	INBOUND;
	/**
	 * Heading out from target to world.
	 */
	OUTBOUND;
}

//
// Message topics
//

/**
 * A message topic.
 */
abstract class MessageTopic {
	/**
	 * The parent message specification.
	 */
	ref MessageSpec[1]#topic spec;
}

/**
 * An event message topic.
 */
class EventTopic extends MessageTopic {
	/**
	 * The name of the event.
	 */
	ref robochart.Event[1] event;
}

/**
 * An operation message topic.
 */
class OperationTopic extends MessageTopic {
	/**
	 * The name of the operation.
	 */
	ref robochart.OperationSig[1] operation;
// TODO: check whether this should be Operation instead
// TODO: parameters
}

//
// Message arguments
//

@genmodel(documentation="Argument pattern.")
abstract class Argument {
}

@genmodel(documentation="Argument pattern specifying an expression.")
class ExpressionArgument extends Argument {
	@genmodel(documentation="The expression in question.")
	val CertExpr[1] expr;
}

@genmodel(documentation="Argument pattern accepting any value.")
class WildcardArgument extends Argument {
	@genmodel(documentation="An optional binding point to receive the value.")
	val Binding[0..1] binding;
}

//
// Message sets
//

/**
 * A defined and named message set.
 */
class NamedMessageSet extends robochart.NamedElement {
	/**
	 * The sequence group on which this message set is defined.
	 */
	ref SequenceGroup#messageSets group;

	/**
	 * The inner message set.
	 */
	val MessageSet[1] set;
}

/**
 * A set of gap message specifications.
 */
abstract class MessageSet {
	/**
	 * Whether this message set has messages.
	 *
	 * For instance, universal message sets are always active, but
	 * extensional ones may be if no messages are held,
	 * reference sets are active iff their referred-to sets are,
	 * and binary message sets depend on the operator and operands.
	 *
	 * This is an optimistic estimate, and may falsely report activity
	 * when there isn't any.
	 */
	derived volatile readonly transient attr boolean active;
	
	/**
	 * Whether this message set contains every message.
	 *
	 * Universal message sets are always universal,
	 * reference sets are active iff their referred-to sets are,
	 * and binary message sets depend on the operator and operands.
	 *
	 * This is a pessimistic estimate, and may falsely deny universality
	 * when there is some.
	 */
	derived volatile readonly transient attr boolean universal;	
}

/**
 * A message set that is, itself, a reference to a previously named message
 * set.
 */
class RefMessageSet extends MessageSet {
	/**
	 * The message set being named.
	 */
	ref NamedMessageSet[1] set;
}

/**
 * A message set that extensionally enumerates allowed or forbidden messages.
 */
class ExtensionalMessageSet extends MessageSet {
	/**
	 * The message specifications held by this message set.
	 */
	!ordered val MessageSpec[*]#parent messages;
}

/**
 * A message set that includes all messages.
 */
class UniverseMessageSet extends MessageSet {
}

@genmodel(documentation="A binary set operation over two message sets.")
class BinaryMessageSet extends MessageSet {
	// NOTE(@MattWindsor91): I've tried making this and other classes have
	// a generic binary superclass, but ran into problems with Xtext being
	// unable to deal with the resulting type erasure.
	
	@genmodel(documentation="The left-hand side.")
	val MessageSet[1] lhs;
	
	@genmodel(documentation="The right-hand side.")
	val MessageSet[1] rhs;
	
	@genmodel(documentation="The operator.")
	attr BinarySetOperator[1] operator;
}

/**
 * A binary set operator.
 */
enum BinarySetOperator {
	/**
	 * Set union ('or').
	 */
	UNION;
	/**
	 * Set intersection ('and').
	 */
	INTERSECTION;
	/**
	 * Set difference ('except').
	 */
	DIFFERENCE;
}

//
// ACTORS
//

/**
 * An actor in a sequence.
 *
 * There are two actors in a sequence: the 'target' of the sequence,
 * which is the system under test; and the 'world', which is the sum of
 * everything connected to the target.  They are bound to names used in the
 * diagram itself, but the target may also name an external RoboChart entity.
 */
abstract class Actor {
	@genmodel(documentation="Typically expands to the target's sequence group parameter.")
	derived volatile transient readonly ref SequenceGroup[0..1] anyGroup;
}

/**
 * The world of a sequence.
 */
class World extends Actor {
	/**
	 * The sequence group to which this actor is attached.
	 */
	ref SequenceGroup[1]#world group;
}

//
// Targets
//

@genmodel(documentation="A target of some specification.

Targets are CSP process sources, through appeal to the existing RoboStar
language semantics.  They are also CSP context sources.")
abstract class Target
extends
	Actor,
	OptionallyNamedElement,
	CSPProcessSource
{
	// TODO(@MattWindsor91): this may eventually weaken to just Group etc.
	@genmodel(documentation="Group to which this actor is attached.")
	ref SequenceGroup[1]#target group;
	
	@genmodel(documentation="Lowest common denominator for the targeted element.")
	derived volatile transient readonly ref robochart.NamedElement[1] element;	
}

/**
 * A sequence target referring to a RoboChart module.
 */
class RCModuleTarget extends Target {
	ref robochart.RCModule[1] module;
}

//
// SEQUENCE PROPERTIES
//

@genmodel(documentation="A property of a sequence.")
class SequenceProperty extends Property {
	@genmodel(documentation="Sequence to which this assertion refers.")
	ref Sequence[1] sequence;

	@genmodel(documentation="Type of assertion.")
	attr SequencePropertyType[1] type;
	
	@genmodel(documentation="Model under which this assertion should be checked under CSP.")
	attr CSPModel[1] model = "TICK_TOCK";	
}

@genmodel(documentation="Type of sequence assertion.")
enum SequencePropertyType {
	@genmodel(documentation="All behaviours of the target are included in the sequence.")
	HOLDS;

	@genmodel(documentation="All behaviours of the sequence are observable on the target.")
	IS_OBSERVED;
}


///////////////////////////////////////////////////////////////////////////////
// LOW-LEVEL LANGUAGES
///////////////////////////////////////////////////////////////////////////////

//
// CSP
//

@genmodel(documentation="A group of raw CSP-M declarations.

We generally interpret CSP-M as tock-CSP and implicitly generate it into a
timed section, but this can be overridden.")
class CSPGroup extends Group {
	@genmodel(documentation="If true, the group should be generated outside of a timed section.")
	attr boolean[1] isUntimed;
	
	@genmodel(documentation="The fragments contained in this group.")
	val CSPFragment[*]#group fragments;
}

//
// CSP fragments
//

@genmodel(documentation="A fragment of CSP-M.

We generally interpret CSP-M as tock-CSP and implicitly generate it into a
timed section, but this can be overridden.")
abstract class CSPFragment {
	@genmodel(documentation="The raw contents of the CSP fragment.")
	attr String[1] contents;
}

@genmodel(documentation="A fragment of CSP-M that has a name.

These are used to bind CSP-M to names that are referred-to elsewhere.")
class NamedCSPFragment extends CSPFragment, robochart.NamedElement {
}

@genmodel(documentation="A fragment of CSP-M that is bound to an event set.")
class EventSetCSPFragment extends NamedCSPFragment, CSPContextSource {
}

@genmodel(documentation="A fragment of CSP-M that is bound to a process.")
class ProcessCSPFragment extends NamedCSPFragment, CSPProcessSource {
	@genmodel(documentation="The source of the context used for tick-tock model shifting.

We cannot, and do not, check to make sure that this accurately represents
the process's actual event universe.")
	ref CSPContextSource[0..1] events;
}

@genmodel(documentation="A fragment of CSP-M that is not bound to anything.

Such fragments can be named, but don't need to be, and nothing in the semantics
will depend on such a name existing.")
class InlineCSPFragment extends CSPFragment, OptionallyNamedElement {
}

//
// CSP properties
//

@genmodel(documentation="A property that requires a low-level CSP refinement relation.")
class CSPRefinementProperty extends Property {
	@genmodel(documentation="Left-hand side of the refinement.")
	ref CSPProcessSource[1] lhs;

	@genmodel(documentation="Left-hand side of the refinement.")
	ref CSPProcessSource[1] rhs;

	@genmodel(documentation="Type of assertion.")
	attr CSPRefinementOperator[1] type;
	
	@genmodel(documentation="Model under which this assertion should be checked under CSP.")
	attr CSPModel[1] model = "TICK_TOCK";	
}

@genmodel(documentation="A tock-CSP refinement operator.")
enum CSPRefinementOperator {
	@genmodel(documentation="LHS refines RHS.")
	REFINES;

	@genmodel(documentation="LHS refines RHS and RHS refines LHS.")
	EQUALS;
}

@genmodel(documentation="A tock-CSP refinement model.")
enum CSPModel {
	@genmodel(documentation="Tick-tock refinement model.")
	TICK_TOCK;
	
	@genmodel(documentation="Traces refinement model (with prioritisation).")
	TRACES;
}

//
// CSP sources
//

@genmodel(documentation="Abstract class of anything that can be interpreted as a tick-tock context.

This is predominantly a marker, and doesn't hold any state of its own.")
abstract class CSPContextSource {
}

@genmodel(documentation="Abstract class of anything that can be interpreted as a CSP process.

All CSP process sources have an underlying tick-tock context source, even if
it is just the empty set.

This is predominantly a marker, and doesn't hold any state of its own.")
abstract class CSPProcessSource extends CSPContextSource {
}
