/**
 * Emfatic projection of the RoboCert metamodel.
 *
 * To use this metamodel, translate it into Ecore using the Emfatic toolchain,
 * then use the MWE2 to generate the support code.
 *
 * Authors:
 * - Matt Windsor (@MattWindsor91): initial model
 */
@namespace(uri="http://robocert.robocalc/", prefix="robocert")
@genmodel
	( basePackage="robocalc.robocert.model"
	, modelPluginID="robocalc.robocert.model"
	, modelDirectory="/robocalc.robocert.model/src-gen"
	, editDirectory="/robocalc.robocert.model.edit/src-gen"
	, editorDirectory="/robocalc.robocert.model.editor/src-gen"
	, testsDirectory="/robocalc.robocert.model.tests/src-gen"
	)
package robocert;

import "platform:/resource/circus.robocalc.robochart/model/robochart.ecore";

/* How to read this model:
 *
 * - With the exception of utility classes, the metamodel is structured based
 *   on how things are (or should be) structured in the RoboCert reference
 *   manual, as well as in the Sirius diagrams..
 * - The Sirius diagrams in `representations.aird` are probably a more
 *   approachable introduction to what is going on here.
 */


///////////////////////////////////////////////////////////////////////////////
// UTILITIES
///////////////////////////////////////////////////////////////////////////////

@genmodel(documentation="An element that might be named, but might not be.

This is usually useful for elements where the name adds some syntactic
complexity but enables cross-reference, and so we want to offer a possible
unnamed variant.")
abstract class OptionallyNamedElement {
	@genmodel(documentation="The name (can be null).")
	attr String[0..1] name;
}


///////////////////////////////////////////////////////////////////////////////
// CORE LANGUAGE
///////////////////////////////////////////////////////////////////////////////

@genmodel(documentation="A RoboCert package.")
class CertPackage extends robochart.BasicPackage {
	@genmodel(documentation="Any groups in this package.

Groups form an ordered list because they can lexically depend on things
defined in previous groups.")
	val Group[*]#parent groups;
}

@genmodel(documentation="A group in a RoboCert package.")
abstract class Group extends OptionallyNamedElement {
	@genmodel(documentation="The parent package.")
	ref CertPackage[1]#groups parent;
}

@genmodel(documentation="A group containing specifications.

Specification groups are context sources by virtue of having a target.")
abstract class SpecGroup extends Group, CSPContextSource {
	@genmodel(documentation="The target of this group.")
	ref Target[1] target;
	@genmodel(documentation="The instantiation in effect in this group.")
	val Instantiation[1]#group instantiation;
}

//
// TARGETS
//

@genmodel(documentation="Group containing one or more specification targets.")
class TargetGroup extends Group {
	@genmodel(documentation="Targets contained in this group.")
	val Target[*]#group targets;
}

@genmodel(documentation="A specification target.

Targets combine several things: a RoboChart element;
a process representing the element from a refinement perspective;
information about the upstream ('context') elements connected to this target;
and information about the downstream elements connected to it.")
abstract class Target extends Process, robochart.NamedElement {
	// TODO(@MattWindsor91): make these OptionallyNamedElements, with the
	// name of the underlying element being the default name.

	@genmodel(documentation="The group to which this target belongs.")
	ref TargetGroup[1]#targets group;
	
	//
	// Derived properties
	//

	// TODO(@MattWindsor91): move parameterisation here?

	@genmodel(documentation="Any components accessible from this target.")
	derived volatile transient readonly ref robochart.ConnectionNode[*] components;

	@genmodel(documentation="Any elements inside the context of this target.")
	derived volatile transient readonly ref robochart.NamedElement[*] contextElements;

	@genmodel(documentation="Lowest common denominator for the targeted element.")
	derived volatile transient readonly ref robochart.NamedElement[1] element;	
}

@genmodel(documentation="A target referring to a robotic system.

This is distinct from ModuleTarget in that it refers to a layer outside of
the module, and its context is the entire world in the RoboWorld sense.")
class SystemTarget extends Target {
	@genmodel(documentation="The module this system encapsulates.")
	ref robochart.RCModule[1] enclosedModule;
}

@genmodel(documentation="A target referring to a RoboChart module.

Such a target has controllers as its components, and the robotic platform as
its context.  Its process is the module process.")
class ModuleTarget extends Target {
	@genmodel(documentation="The module referred to by this target.")
	ref robochart.RCModule[1] module;
}

@genmodel(documentation="A target referring to a RoboChart controller.")
class ControllerTarget extends Target {
	@genmodel(documentation="The controller referred to by this target.")
	ref robochart.Controller[1] controller;
}

@genmodel(documentation="Uses the target of a specification group as a process source.

This includes any instantiation for the target parameters.")
class TargetGroupSource extends Process {
	// TODO(@MattWindsor91): this is not a good workaround for the issue of
	// needing to take these things as process sources.
	@genmodel(documentation="The group whose target we are referencing.")
	ref SpecGroup[1] targetGroup;
}

//
// Instantiations
//

@genmodel(documentation="Specifies a (partial) instantiation of targets in a group.")
class Instantiation {
	@genmodel(documentation="The parent group of this instantiation.")
	ref SpecGroup[1]#instantiation group;

	@genmodel(documentation="Any constant assignments.")
	val ConstAssignment[*] assignments;

	@genmodel(documentation="Gets any available instantiation for the constant in this instantiation.")	
	derived readonly transient volatile op CertExpr[0..1] getConstant(robochart.Variable constant); 
}

@genmodel(documentation="Assigns a value to one or more constants.")
class ConstAssignment {
	@genmodel(documentation="The constant(s) being assigned.")
	ref robochart.Variable[+] constants;
	
	@genmodel(documentation="The expression containing the new value of the constant(s).")
	val CertExpr[1] value;
	
	@genmodel(documentation="Checks whether this assignment maps the given constant.")
	derived readonly transient volatile op boolean[1] hasConstant(robochart.Variable constant);
}

//
// ASSERTIONS
//

@genmodel(documentation="An assertion group.")
class AssertionGroup extends Group {
	val Assertion[*]#group assertions;
}

@genmodel(documentation="An assertion.")
class Assertion extends robochart.NamedElement {
	@genmodel(documentation="The group to which this assertion belongs.")
	ref AssertionGroup[1]#assertions group;

	@genmodel(documentation="The root property of the assertion.")
	val Property[1] property;
}

@genmodel(documentation="A property in an assertion.")
abstract class Property {
	// TODO(@MattWindsor91): we may eventually want conjunctions/disjunctions,
	// in which case I might need to re-evaluate whether negated belongs here.

	@genmodel(documentation="Whether the assertion must fail to hold for the model to be validated.")
	attr boolean[1] negated;
}

//
// Core properties
//

@genmodel(documentation="A core property.")
class CoreProperty extends Property {
	// TODO(@MattWindsor91): it may one day be the case that core properties
	// should accept things other than CSP process sources, eg if we track
	// those properties in other backends, or if we add clock initialised
	// properties.

	@genmodel(documentation="The subject of the property.")
	ref Process[1] subject;
	
	@genmodel(documentation="The specific type of property being investigated.")
	attr CorePropertyType[1] type;
}

@genmodel(documentation="Enumeration of core properties.")
enum CorePropertyType {
	@genmodel(documentation="Timelock freedom.")
	TIMELOCK_FREE;
	@genmodel(documentation="Timed deadlock freedom.")
	DEADLOCK_FREE;
	@genmodel(documentation="Determinism.")
	DETERMINISM;
	@genmodel(documentation="Termination.")
	TERMINATION;
	// TODO(@MattWindsor91): clock initialisation
}

// TODO(@MattWindsor91): binary types

//
// EXPRESSIONS
//
// Generally, operator expressions are grouped into equivalence classes based
// on similar semantic function and wellformedness conditions; for instance,
// the relational operators are all in the same class.  This differs from
// RoboChart, so it might change later.
//

@genmodel(documentation="A RoboCert expression.")
abstract class CertExpr {
}

//
// Literals
//

@genmodel(documentation="A RoboCert Boolean literal.")
class BoolExpr extends CertExpr {
	@genmodel(documentation="The truth value of the expression.")
	attr boolean[1] truth;
}

@genmodel(documentation="A RoboCert integer literal.")
class IntExpr extends CertExpr {
	@genmodel(documentation="The value of the expression.")
	attr int[1] value;
}

//
// Unary operations
//

@genmodel(documentation="An expression that inverts the sign of another (arithmetic) expression.")
class MinusExpr extends CertExpr {
	// NOTE(@MattWindsor91): if there is ever a compelling reason to add more
	// arithmetic unary operators, this should generalise to fit all of them.

	@genmodel(documentation="The expression to modify.")
	val CertExpr[1] expr; 
}

//
// Binary operations
//

@genmodel(documentation="A binary expression.")
abstract class BinaryExpr extends CertExpr {
	// NOTE(@MattWindsor91): I've tried making this and other classes have
	// a generic binary superclass, but ran into problems with Xtext being
	// unable to deal with the resulting type erasure.

	@genmodel(documentation="The left-hand side.")
	val CertExpr[1] lhs;
	
	@genmodel(documentation="The right-hand side.")
	val CertExpr[1] rhs;	
}

@genmodel(documentation="A logical binary expression.")
class LogicalExpr extends BinaryExpr {	
	@genmodel(documentation="The operator.")
	attr LogicalOperator[1] operator;
}

@genmodel(documentation="A logical operator.")
enum LogicalOperator {
	@genmodel(documentation="Logical conjunction.")
	AND;
	@genmodel(documentation="Logical disjunction.")
	OR;
}

@genmodel(documentation="A relational binary expression.")
class RelationExpr extends BinaryExpr {
	// TODO(@MattWindsor91): consider splitting </<=/>=/> and ==/!=, as
	// they have different wellformedness conditions (eg, the former requires
	// arithmetic types).
	
	@genmodel(documentation="The operator.")
	attr RelationOperator[1] operator;
}

@genmodel(documentation="A relational operator.")
enum RelationOperator {
	@genmodel(documentation="Greater than.")
	GT;
	@genmodel(documentation="Greater than or equal.")
	GE;
	@genmodel(documentation="Equal.")
	EQ;
	@genmodel(documentation="Not equal.")
	NE;
	@genmodel(documentation="Greater than or equal.")
	LE;
	@genmodel(documentation="Less than.")
	LT;
}

//
// Variables
//

@genmodel(documentation="A reference to a constant in the model.")
class ConstExpr extends CertExpr {
	@genmodel(documentation="The constant being referenced.")
	ref robochart.Variable[1] constant;
}

@genmodel(documentation="A reference to a previously-bound RoboCert variable.")
class BindingExpr extends CertExpr {
	@genmodel(documentation="The source of the variable being bound.") 
	ref Binding[1] source;

	// We could track a bidirectional reference here, but Xtext doesn't like it.
}

@genmodel(documentation="A binding point.")
class Binding extends robochart.NamedElement {
}

//
// MODALITIES
//

@genmodel(documentation="Temperature modality.")
enum Temperature {
	@genmodel(documentation="Cold temperature; no obligation on model to ensure progress.")
	COLD;
	@genmodel(documentation="Hot temperature; obligation on model to ensure progress.")
	HOT;	
}


///////////////////////////////////////////////////////////////////////////////
// SEQUENCES
///////////////////////////////////////////////////////////////////////////////

@genmodel(documentation="A collection of sequence diagrams.")
class SequenceGroup extends SpecGroup {
	@genmodel(documentation="Any message sets named on the sequence group.")
	!ordered val NamedMessageSet[*]#group messageSets;
	
	@genmodel(documentation="The sequences inside this sequence group.")
	!ordered val Sequence[*]#group sequences;
	
	@genmodel(documentation="The actors participating in this sequence.

These correspond to UML lifelines.")
	!ordered val Actor[2..*]#group actors;

	
	//
	// Derived properties
	//

	// NOTE(@MattWindsor91): these derivations have to be on the *group*, not
	// the sequences.  This is because implicit edges in message sets rely on
	// these existing.

	@genmodel(documentation="Shortcut for getting the target actor of the group, if any.")
	derived volatile transient readonly ref TargetActor[0..1] targetActor;
	
	@genmodel(documentation="Shortcut for getting the world of the group, if any.")
	derived volatile transient readonly ref World[0..1] world;
}

@genmodel(documentation="A sequence diagram.")
class Sequence extends robochart.NamedElement, Process {
	@genmodel(documentation="The group to which this sequence belongs.")
	ref SequenceGroup[1]#sequences group;
	@genmodel(documentation="The top-level subsequence of the sequence diagram.")
	val Subsequence[1] body;
	@genmodel(documentation="The set of group actors forming lifelines in this diagram.

The order determines that in which lifelines are shown in the graphical notation.")
	ordered ref Actor[2..*] lifelines;
}

@genmodel(documentation="A contiguous ordered list of interaction fragments.")
class Subsequence {
	@genmodel(documentation="The interaction fragments contained within the subsequence.")
	ordered val InteractionFragment[*]#parent fragments;
	
	@genmodel(documentation="The parent sequence.")
	derived volatile transient readonly ref Sequence[0..1] sequence;
}

//
// STEPS
//

// NOTE: When adding new steps, remember to extend the step generators.

@genmodel(documentation="A single interaction fragment in a subsequence.")
abstract class InteractionFragment {
	@genmodel(documentation="The parent subsequence of this step.")
	ref Subsequence[1]#fragments parent;
}

//
// Non-block steps
//

@genmodel(documentation="An interaction fragment referring to a particular occurrence in time.")
class OccurrenceFragment extends InteractionFragment {
	@genmodel(documentation="The occurrence proper.")
	val Occurrence[1]#fragment occurrence;
	
	@genmodel(documentation="The temperature of this occurrence.")
	attr Temperature[1] temperature;
}

//
// Block steps
//

@genmodel(documentation="Step that contains exactly one body.

Often, but not always, these will be (what UML would call) combined
fragments.

Block steps can optionally have a name, which allows breaking.")
abstract class BlockStep extends InteractionFragment, OptionallyNamedElement {
	@genmodel(documentation="The body of the block.")
	val Subsequence[1] body;
}

@genmodel(documentation="Step imposing a termination deadline on a block.")
class DeadlineStep extends BlockStep {
	@genmodel(documentation="Deadline, in time units after the start of the block.")
	val CertExpr[1] units;
}

@genmodel(documentation="An interaction fragment blocking the diagram until any occurrence happens on the block.

This is an extension to UML.")
class UntilFragment extends BlockStep {
	@genmodel(documentation="The messages that may occur while waiting for 'body'.")
	val MessageSet[1] intraMessages;
}

@genmodel(documentation="A step containing one or more sequence elements in loop.")
class LoopStep extends BlockStep {
	@genmodel(documentation="The loop bound.")
	val LoopBound[1] bound;

	// TODO: conditionals
}

//
// Loop bounds
//

@genmodel(documentation="A bound on the number of iterations the loop can make.")
abstract class LoopBound {
}

@genmodel(documentation="A loop bound that makes the loop execute infinitely until otherwise broken.")
class InfiniteLoopBound extends LoopBound {
}

@genmodel(documentation="A loop bound that executes a specific number of times.

Corresponds to UML2 loop(times).")
class DefiniteLoopBound extends LoopBound {
	@genmodel(documentation="The number of times the loop must execute, unless prematurely broken.

Evaluated once only.")
 	val CertExpr[1] times;
}

@genmodel(documentation="A loop bound that executes a nondeterministic number of times that is at least a lower bound.

Corresponds to UML2 loop(lowerTimes, *).")
class LowerLoopBound extends LoopBound {
	@genmodel(documentation="Lower number of times the loop must execute, unless prematurely broken.

Evaluated once only.")
 	val CertExpr[1] lowerTimes;
}

@genmodel(documentation="A loop bound that executes a nondeterministic number of times between two bounds.

Corresponds to UML2 loop(lowerTimes, upperTimes).")
class RangeLoopBound extends LoopBound {
	@genmodel(documentation="Lower number of times the loop must execute, unless prematurely broken.

Evaluated once only.")
	val CertExpr[1] lowerTimes;
	@genmodel(documentation="The upper number of times the loop must execute.

Evaluated once only.")
	val CertExpr[1] upperTimes;
}

//
// Branch fragments
//

@genmodel(documentation="Abstract step containing two or more branches.")
abstract class BranchStep extends InteractionFragment {
	@genmodel(documentation="The branches available in this step.")
	val Branch[2..*]#parent branches;
}

@genmodel(documentation="An alternative choice step.")
class AlternativeStep extends BranchStep {
	@genmodel(documentation="The temperature of this alternative.")
	attr Temperature[1] temperature;
}

@genmodel(documentation="An interleaving composition step.")
class InterleaveStep extends BranchStep {
}

@genmodel(documentation="A potentially-guarded subsequence used in a BranchStep.")
class Branch {
	@genmodel(documentation="The guard for this branch.")
	val Guard[1]#parent guard;
	
	@genmodel(documentation="The body of this branch.")
	val Subsequence[1] body;
	
	// This mainly exists to allow us to (eventually) set up ElseGuards,
	// which require us to traverse up to the Branch, enumerate all the
	// expressions, and negate them.
	@genmodel(documentation="The parent step containing this branch (along with others).")
	ref BranchStep[1]#branches parent;
}

@genmodel(documentation="A condition placed on a Branch.")
abstract class Guard {
	@genmodel(documentation="The parent branch of this guard.")
	ref Branch[1]#guard parent;
}

@genmodel(documentation="A guard that is always true.")
class EmptyGuard extends Guard {
}

@genmodel(documentation="A guard that is dependent on the truth value of an expression.")
class ExprGuard extends Guard {
	val CertExpr[1] expr;
}

@genmodel(documentation="A guard that is true if all other guards in the BranchStep are false.

It is ill-formed to have multiple ElseGuards in a step, or to have both an
ElseGuard and an EmptyGuard in a step.")
class ElseGuard extends Guard {
}

//
// OCCURRENCES
//

@genmodel(documentation="An occurrence in a sequence.")
abstract class Occurrence {
	@genmodel(documentation="The fragment containing this action.")
	ref OccurrenceFragment[1]#occurrence fragment;
}

@genmodel(documentation="A communicating action in a sequence.")
class ArrowAction extends Occurrence {
	@genmodel(documentation="The body of the arrow.")
	val MessageSpec[1] body;
}

@genmodel(documentation="Represents a deadlock event in a sequence.")
class FinalAction extends Occurrence {
}

@genmodel(documentation="Represents a wait for some amount of time units.")
class WaitAction extends Occurrence {
	@genmodel(documentation="The number of units to wait.")
	val CertExpr[1] units;
	
	// TODO(@MattWindsor91): nondeterministic waits
}

//
// MESSAGES
//

@genmodel(documentation="A specification of a message.")
class MessageSpec {
	@genmodel(documentation="The topic of the message.")
	val MessageTopic[1]#spec topic;
	
	@genmodel(documentation="The argument list for the message.")
	val Argument[*] arguments;
	
	@genmodel(documentation="The pair of actors participating in this message.")
	val Edge[1]#spec edge;
}

//
// Edges
//

@genmodel(documentation="A pair of actors referenced by a MessageSpec.

There are multiple ways to resolve this pair, and so multiple subclasses of Edge.")
abstract class Edge {
	@genmodel(documentation="The parent MessageSpec.")
	ref MessageSpec[1]#edge spec;

	//
	// Derived references
	//
	
	@genmodel(documentation="The resolved source of the message.")
	derived transient readonly volatile ref Actor[1] resolvedFrom;
	@genmodel(documentation="The resolved destination of the message.")
	derived transient readonly volatile ref Actor[1] resolvedTo;
}

@genmodel(documentation="An explicit edge.")
class ExplicitEdge extends Edge {
	// TODO(@MattWindsor91): it is unclear whether these should be allowed
	// in bidirectional diagrams, as that raises ambiguity at the graphical
	// notation level.

	@genmodel(documentation="The source of the message.")
	ref Actor[1] from;
	@genmodel(documentation="The destination of the message.")
	ref Actor[1] to;
}

@genmodel(documentation="An edge implied by a direction.

Such edges are only valid when there are two actors in the sequence,
one of the actors is a target, and the other is a world.
They also won't work if the message is not embedded in a sequence group.
")
class ImplicitEdge extends Edge {
	@genmodel(documentation="The direction of the pair.")
	attr EdgeDirection[1] direction = "OUTBOUND";
}

@genmodel(documentation="The direction of an implicit edge.")
enum EdgeDirection {
	@genmodel(documentation="Heading out from target to world.

This is the default when no direction is specified, primarily to accommodate
operations where it is the only allowed direction.")
	OUTBOUND;
	@genmodel(documentation="Heading in from world to target.")
	INBOUND;
}

//
// Message topics
//

@genmodel(documentation="A message topic.")
abstract class MessageTopic {
	@genmodel(documentation="The parent message specification.")
	ref MessageSpec[1]#topic spec;
	
	//
	// Derived properties
	//
	
	@genmodel(documentation="The types of all parameters accepted by this topic.

For event topics, there is at most one pseudo-parameter: the type of the event.")
	derived transient readonly volatile ref robochart.Type[*] paramTypes;	
}

@genmodel(documentation="An event message topic.")
class EventTopic extends MessageTopic {
	@genmodel(documentation="The name of the event.")
	ref robochart.Event[1] event;
}

@genmodel(documentation="An operation message topic.")
class OperationTopic extends MessageTopic {
	@genmodel(documentation="The name of the operation.")
	ref robochart.OperationSig[1] operation;
}

//
// Message arguments
//

@genmodel(documentation="Argument pattern.")
abstract class Argument {
}

@genmodel(documentation="Argument pattern specifying an expression.")
class ExpressionArgument extends Argument {
	@genmodel(documentation="The expression in question.")
	val CertExpr[1] expr;
}

@genmodel(documentation="Argument pattern accepting any value.")
class WildcardArgument extends Argument {
	@genmodel(documentation="An optional binding point to receive the value.")
	val Binding[0..1] binding;
}

//
// Message sets
//

@genmodel(documentation="A defined and named message set.")
class NamedMessageSet extends robochart.NamedElement {
	@genmodel(documentation="The sequence group on which this message set is defined.")
	ref SequenceGroup#messageSets group;

	@genmodel(documentation="The inner message set.")
	val MessageSet[1] set;
}

@genmodel(documentation="A set of message specifications.")
abstract class MessageSet {
	@genmodel(documentation="Whether this message set has messages.

For instance, universal message sets are always active, but extensional ones may be if no messages are held,
reference sets are active iff their referred-to sets are,
and binary message sets depend on the operator and operands.

This is an optimistic estimate, and may falsely report activity when there isn't any.")
	derived volatile readonly transient attr boolean active;
	
	@genmodel(documentation="Whether this message set contains every message.

Universal message sets are always universal,
reference sets are active iff their referred-to sets are,
and binary message sets depend on the operator and operands.

This is a pessimistic estimate, and may falsely deny universality when there is some.")
	derived volatile readonly transient attr boolean universal;	
}

@genmodel(documentation="A message set that is a reference to a previously named message set.")
class RefMessageSet extends MessageSet {
	@genmodel(documentation="The message set being named.")
	ref NamedMessageSet[1] set;
}

@genmodel(documentation="A message set that extensionally enumerates messages.")
class ExtensionalMessageSet extends MessageSet {
	@genmodel(documentation="The message specifications held by this message set.")
	!ordered val MessageSpec[*]#parent messages;
}

@genmodel(documentation="A message set that includes all messages.")
class UniverseMessageSet extends MessageSet {
}

@genmodel(documentation="A binary set operation over two message sets.")
class BinaryMessageSet extends MessageSet {
	// NOTE(@MattWindsor91): I've tried making this and other classes have
	// a generic binary superclass, but ran into problems with Xtext being
	// unable to deal with the resulting type erasure.
	
	@genmodel(documentation="The left-hand side.")
	val MessageSet[1] lhs;
	
	@genmodel(documentation="The right-hand side.")
	val MessageSet[1] rhs;
	
	@genmodel(documentation="The operator.")
	attr BinarySetOperator[1] operator;
}

@genmodel(documentation="A binary set operator.")
enum BinarySetOperator {
	@genmodel(documentation="Set union ('or').")
	UNION;
	@genmodel(documentation="Set intersection ('and').")
	INTERSECTION;
	@genmodel(documentation="Set difference ('except').")
	DIFFERENCE;
}

//
// ACTORS
//

@genmodel(documentation="An actor in a sequence.

Actors have names, for use in lifelines and ExplicitEdges.")
abstract class Actor extends robochart.NamedElement {
	// NOTE(@MattWindsor91): it would have been more idiomatic to have Actors
	// belong to Sequences rather than SequenceGroups, but MessageSets would
	// need either a complex setup to pick up Actors _or_ would need defining
	// within Sequences.

	@genmodel(documentation="The sequence group to which these actors belong.")
	ref SequenceGroup[1]#actors group;
}

@genmodel(documentation="Actor that stands for the current target.")
class TargetActor extends Actor {
}

@genmodel(documentation="Actor that stands for the environment of the current target.")
class World extends Actor {
}

@genmodel(documentation="Actor that references a component of the target.")
class ComponentActor extends Actor {
	@genmodel(documentation="Component being referenced.

It is ill-formed for this node to not be a component of the target,
and also ill-formed for the same component to form multiple actors.")
	ref robochart.ConnectionNode[1] node;
}


//
// SEQUENCE PROPERTIES
//

@genmodel(documentation="A property of a sequence.")
class SequenceProperty extends Property {
	@genmodel(documentation="Sequence to which this assertion refers.")
	ref Sequence[1] sequence;

	@genmodel(documentation="Type of assertion.")
	attr SequencePropertyType[1] type;
	
	@genmodel(documentation="Model under which this assertion should be checked under CSP.")
	attr CSPModel[1] model = "TICK_TOCK";	
}

@genmodel(documentation="Type of sequence assertion.")
enum SequencePropertyType {
	@genmodel(documentation="All behaviours of the target are included in the sequence.")
	HOLDS;

	@genmodel(documentation="All behaviours of the sequence are observable on the target.")
	IS_OBSERVED;
}


///////////////////////////////////////////////////////////////////////////////
// LOW-LEVEL LANGUAGES
///////////////////////////////////////////////////////////////////////////////

//
// CSP
//

@genmodel(documentation="A group of raw CSP-M declarations.

We generally interpret CSP-M as tock-CSP and implicitly generate it into a
timed section, but this can be overridden.")
class CSPGroup extends SpecGroup {
	@genmodel(documentation="If true, the group should be generated outside of a timed section.")
	attr boolean[1] untimed;
	
	@genmodel(documentation="The fragments contained in this group.")
	val CSPFragment[*]#group fragments;
}

//
// CSP fragments
//

@genmodel(documentation="A fragment of CSP-M.

We generally interpret CSP-M as tock-CSP and implicitly generate it into a
timed section, but this can be overridden.")
abstract class CSPFragment {
	@genmodel(documentation="The raw contents of the CSP fragment.")
	attr String[1] contents;
}

@genmodel(documentation="A fragment of CSP-M that has a name.

These are used to bind CSP-M to names that are referred-to elsewhere.")
class NamedCSPFragment extends CSPFragment, robochart.NamedElement {
}

@genmodel(documentation="A fragment of CSP-M that is bound to an event set.")
class EventSetCSPFragment extends NamedCSPFragment, CSPContextSource {
}

@genmodel(documentation="A fragment of CSP-M that is bound to a process.")
class ProcessCSPFragment extends NamedCSPFragment, Process {
	@genmodel(documentation="The source of the context used for tick-tock model shifting.

We cannot, and do not, check to make sure that this accurately represents
the process's actual event universe.")
	ref CSPContextSource[0..1] events;
}

@genmodel(documentation="A fragment of CSP-M that is not bound to anything.

Such fragments can be named, but don't need to be, and nothing in the semantics
will depend on such a name existing.")
class InlineCSPFragment extends CSPFragment, OptionallyNamedElement {
}

//
// CSP properties
//

@genmodel(documentation="A property that requires a low-level CSP refinement relation.")
class CSPRefinementProperty extends Property {
	@genmodel(documentation="Left-hand side of the refinement.")
	ref Process[1] lhs;

	@genmodel(documentation="Left-hand side of the refinement.")
	ref Process[1] rhs;

	@genmodel(documentation="Type of assertion.")
	attr CSPRefinementOperator[1] type;
	
	@genmodel(documentation="Model under which this assertion should be checked under CSP.")
	attr CSPModel[1] model = "TICK_TOCK";	
}

@genmodel(documentation="A tock-CSP refinement operator.")
enum CSPRefinementOperator {
	@genmodel(documentation="LHS refines RHS.")
	REFINES;

	@genmodel(documentation="LHS refines RHS and RHS refines LHS.")
	EQUALS;
}

@genmodel(documentation="A tock-CSP refinement model.")
enum CSPModel {
	@genmodel(documentation="Tick-tock refinement model.")
	TICK_TOCK;
	
	@genmodel(documentation="Traces refinement model (with prioritisation).")
	TRACES;
}

//
// CSP sources
//

@genmodel(documentation="Abstract class of anything that can be interpreted as a tick-tock context.

This is predominantly a marker, and doesn't hold any state of its own.")
abstract class CSPContextSource {
}

@genmodel(documentation="Abstract class of anything that can be interpreted as a CSP process.

All CSP process sources have an underlying tick-tock context source, even if
it is just the empty set.

This is predominantly a marker, and doesn't hold any state of its own.")
abstract class Process extends CSPContextSource {
}
