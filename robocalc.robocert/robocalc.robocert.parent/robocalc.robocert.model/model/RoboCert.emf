@namespace(uri="http://robocert.robocalc/", prefix="robocert")
@genmodel
	( basePackage="robocalc.robocert.model"
	, modelPluginID="robocalc.robocert.model"
	, modelDirectory="/robocalc.robocert.model/src-gen"
	, editDirectory="/robocalc.robocert.model.edit/src-gen"
	, editorDirectory="/robocalc.robocert.model.editor/src-gen"
	, testsDirectory="/robocalc.robocert.model.tests/src-gen"
	)
package robocert;

import "platform:/resource/circus.robocalc.robochart/model/robochart.ecore";

/**
 * A RoboCert package.
 */
class RAPackage extends robochart.BasicPackage {
	/**
	 * Any top-level CSP fragments in this package.
	 * 
	 * TODO: these will likely go away once we have a way of resolving files.
	 */
	val CSPFragment[*] cspFragments;
	val Sequence[*] sequences;
	val Assertion[*] assertions;
}

//
// CSP FRAGMENTS
//
/**
 * A fragment of CSP-M.
 */
class CSPFragment {
	/**
	 * The raw contents of the CSP fragment.
	 */
	attr String[1] contents;
}

//
// SEQUENCES
//

/**
 * A sequence of steps, forming part or all of a sequence diagram.
 */
class Subsequence {
	/**
	 * The steps contained within the subsequence.
	 * There is always at least one step.
	 */
	val SequenceStep[+]#parent steps;
}

/**
 * A sequence diagram.
 *
 * Well-formed sequence diagrams end with a final or infinite loop action.
 */
class Sequence extends robochart.NamedElement {
	/**
	 * The target actor of the sequence diagram.
	 */
	val TargetActor[1]#sequence target;
	/**
	 * The world actor of the sequence diagram.
	 */
	val World[1]#sequence world;
	/**
	 * The top-level subsequence of the sequence diagram.
	 */
	val Subsequence[1] body;
}

/**
 * An actor in a sequence.
 *
 * There are two actors in a sequence: the 'target' of the sequence,
 * which is the system under test; and the 'world', which is the sum of
 * everything connected to the target.  They are bound to names used in the
 * diagram itself, but the target may also name an external RoboChart entity.
 */
abstract class Actor extends robochart.NamedElement {
}

/**
 * The world of a sequence.
 */
class World extends Actor {
	/**
	 * The sequence to which this actor is attached.
	 */
	ref Sequence[1]#world sequence;
}

/**
 * An actor referring to a target.
 *
 * This class serves mainly to attach a name to a target so it can be referred
 * to in arrows.
 */
class TargetActor extends Actor {
	/**
	 * The sequence to which this actor is attached.
	 */
	ref Sequence[1]#target sequence;

	/**
	 * The enclosed target.
	 */
	val Target[1] target;
}

/**
 * A target of a sequence.
 */
abstract class Target {
}

/**
 * A sequence target referring to a RoboChart module.
 */
class RCModuleTarget extends Target {
	ref robochart.RCModule[1] module;
}

/**
 * A sequence target overriding constants on another sequence target.
 */
class OverrideTarget extends Target {
	/**
	 * The overridden target.
	 */
	val Target[1] target;
	/**
	 * The overrides being applied.
	 */
	val ConstOverride[+] overrides;
}

/**
 * A constant override.
 */
class ConstOverride {
	// NOTE: this would ideally be a Map.Entry, but I couldn't get
	// Xtend's serializer code generator to work with EMaps. 

	/**
	 * The constant being overridden.
	 */
	ref robochart.Variable[1] key;
	/**
	 * The new value of the constant.
	 */
	val robochart.Expression[1] value;
}

/**
 * A single step in a subsequence.
 */
class SequenceStep {
	/**
	 * The parent subsequence of this step.
	 */
	ref Subsequence[1]#steps parent;

	/**
	 * The specification of what can happen in the 'gap' before the step.
	 */
	val SequenceGap[1] gap;

	/**
	 * The component inside the sequence step.
	 */
	val SequenceAction[1] action;
}

/**
 * A specification of which internal communications can happen before a
 * sequence step, or at the end of a sequence diagram.
 */
abstract class SequenceGap {
}

/**
 * A sequence gap that permits no implicit communications.
 */
class StrictGap extends SequenceGap {
}

/**
 * A sequence gap that permits implicit communications.
 */
class LooseGap extends SequenceGap {
	/**
	 * The messages forbidden by this gap.
	 * The empty set is considered to be 'all messages are allowed'.
	 */
	val GapMessageSet[1] allowed;

	/**
	 * The messages forbidden by this gap.
	 * The empty set is considered to be 'no messages are forbidden'.
	 */
	val GapMessageSet[1] forbidden;
}

/**
 * A set of gap message specs, used in loose sequence gaps.
 */
class GapMessageSet {
	/**
	 * The message specifications held by this message set.
	 */
	val GapMessageSpec[*]#parent messages;
}


/**
 * An action in a sequence diagram.
 */
abstract class SequenceAction {
}

/**
 * A communicating action in a sequence diagram.
 */
class ArrowAction extends SequenceAction {
	/**
	 * The body of the arrow.
	 */
	val ArrowMessageSpec[1]#parent body;
}

/**
 * An action containing one or more sequence elements in loop.
 *
 * A loop action has a name; this is used both in its semantic elaboration and
 * also as a target for any break actions.
 */
class LoopAction extends robochart.NamedElement, SequenceAction {
	// TODO: conditionals
	// TODO: break
	/**
	 * The body of the loop.
	 */
	val Subsequence[1] body;
}

/**
 * A special action marking the end of a diagram.
 *
 * This exists mainly to allow a sequence gap at the end of the diagram.
 */
class FinalAction extends SequenceAction {
}

//
// Message specs
//

/**
 * A specification of a message.
 */
abstract class MessageSpec {
	/**
	 * The topic of the message.
	 */
	val MessageTopic[1] topic;
	/**
	 * The source of the message.
	 */
	ref Actor[1] from;
	/**
	 * The target of the message.
	 */
	ref Actor[1] to;
}

/**
 * A message specification corresponding to an arrow on a sequence diagram.
 */
class ArrowMessageSpec extends MessageSpec {
	/**
	 * The parent of the arrow.
	 */
	ref ArrowAction[1]#body parent;
}

/**
 * A message specification corresponding to an entry in a gap list.
 */
class GapMessageSpec extends MessageSpec {
	/**
	 * The parent gap.
	 */
	ref GapMessageSet[1]#messages parent;
}

//
// Message topics
//

/**
 * A message topic.
 */
abstract class MessageTopic {
}

/**
 * An event message topic.
 */
class EventTopic extends MessageTopic {
	/**
	 * The name of the event.
	 */
	ref robochart.Event[1] event;
// TODO: parameter
}

/**
 * An operation message topic.
 */
class OperationTopic extends MessageTopic {
	/**
	 * The name of the operation.
	 */
	ref robochart.OperationSig[1] operation;
// TODO: check whether this should be Operation instead
// TODO: parameters
}

//
// ASSERTIONS
//
/**
 * A RoboCert assertion, containing a named body with metadata.
 */
class Assertion extends robochart.NamedElement {
	/**
	 * The body containing the part of the assertion that can vary.
	 */
	val AssertionBody[1]#parent body;
	/**
	 * The model under which this assertion should be checked if converted to (untimed) CSP.
	 * 
	 * TODO: is this always useful?
	 */
	attr CSPModel[1] model = "Traces";
}

/**
 * An assertion body.
 */
abstract class AssertionBody {
	/**
	 * The parent assertion.
	 */
	ref Assertion[1]#body parent;
}

/**
 * A RoboCert sequence assertion body.
 */
abstract class SequenceAssertionBody extends AssertionBody {
	/**
	 * The sequence to which this assertion refers.
	 */
	ref Sequence[1] sequence;
	/**
	 * Whether the assertion must fail to hold for the model to be validated.
	 */
	attr boolean[1] isNegated;
}

/**
 * A sequence assertion body that requires that the behaviour described by the
 * sequence is (or is not) observable by the model.
 */
class ObservedSequenceAssertionBody extends SequenceAssertionBody {
}

/**
 * A sequence assertion body that requires that the behaviour described by the
 * sequence is (or is not) implemented by the model.
 */
class ImplementedSequenceAssertionBody extends SequenceAssertionBody {
}

/**
 * A CSP refinement model.
 */
enum CSPModel {
	Traces;
	Failures;
	FailuresDivergences;
}