/*
 * generated by Xtext 2.25.0
 */
package robocalc.robocert.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import static robocalc.robocert.model.robocert.RobocertPackage.Literals.*
import static extension org.eclipse.xtext.EcoreUtil2.getContainerOfType
import org.eclipse.xtext.scoping.Scopes
import robocalc.robocert.model.robocert.Target
import robocalc.robocert.generator.utils.TargetExtensions
import com.google.inject.Inject
import org.eclipse.xtext.scoping.IScope
import robocalc.robocert.model.robocert.ConstAssignment
import robocalc.robocert.model.robocert.SequenceAssertion

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class RoboCertScopeProvider extends AbstractRoboCertScopeProvider {
	@Inject extension TargetExtensions
	
	override getScope(EObject context, EReference reference) {
		getScopeInner(context, reference)
	}
	
	/**
	 * Special scoping for constants in a constant assignment.
	 * 
	 * @param context    the scoping context.
	 * @param reference  the reference.
	 * 
	 * @return  the provided scope.
	 */
	private def dispatch getScopeInner(ConstAssignment context, EReference reference) {
		var IScope scope = null
		if (reference == CONST_ASSIGNMENT__KEY) {
			scope = context.constAssignmentScope
		}
		
		scope ?: super.getScope(context, reference)	
	}
	
	/**
	 * Fallback scoping for when we haven't manually overridden anything.
	 * 
	 * @param context    the scoping context.
	 * @param reference  the reference.
	 * 
	 * @return  the provided scope.
	 */
	private def dispatch getScopeInner(EObject context, EReference reference) {
		super.getScope(context, reference)
	}
	
	private def constAssignmentScope(ConstAssignment it) {
		sequenceConstAssignmentScope ?: assertionConstAssignmentScope
	}

	/**
	 * Tries to get the scope of a constant assignment by walking back to a
	 * target actor, then retrieving its parametrisation.
	 */
	private def sequenceConstAssignmentScope(ConstAssignment it) {
		// TODO(@MattWindsor91): this should be part of the metamodel, somehow.
		getContainerOfType(Target)?.targetScope
	}
	
	/**
	 * Gets the target of a constant assignment by walking back to an
	 * assertion, then retrieving its sequence's target's uninstantiated
	 * constants.
	 */
	 private def assertionConstAssignmentScope(ConstAssignment it) {
		// TODO(@MattWindsor91): this should be part of the metamodel, somehow.
		getContainerOfType(SequenceAssertion)?.sequence?.target?.uninstantiatedTargetScope
	}
	
	/**
	 * Produces a scope containing all of the constants defined on a target.
	 * 
	 * @param it  the target in question.
	 * 
	 * @return  the target's constants as a scope.
	 */
	private def targetScope(Target it) {
		Scopes.scopeFor(constants.toIterable)
	} 
	
	/**
	 * Produces a scope containing any uninstantiated constants defined on a target.
	 * 
	 * @param it  the target in question.
	 * 
	 * @return  the target's constants as a scope.
	 */
	private def uninstantiatedTargetScope(Target it) {
		Scopes.scopeFor(uninstantiatedConstants.toIterable)
	} 
}
