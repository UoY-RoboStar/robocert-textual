// automatically generated by Xtext
grammar robocalc.robocert.RoboCert with circus.robocalc.robochart.textual.RoboChart

import "http://robocert.robocalc/" 
import "http://www.robocalc.circus/RoboChart"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/**
 * A top-level assertions package.
 */
RAPackage:
	( cspFragments += CSPFragment
	| sequences += Sequence
	| assertions += NamedAssertion
	)*;

/**
 * A raw CSP fragment.
 * 
 * TODO: per meta-model, these will likely go away later on, replaced with
 *       process-bound CSP fragments only.
 */

CSPFragment:
	'include' contents = CSP_CODE;

terminal CSP_CODE: 'csp-begin' -> 'csp-end';

///////////////////////////////////////////////////////////////////////////////
// Sequence diagrams
///////////////////////////////////////////////////////////////////////////////

/*
 * Open design questions:
 * 
 * 0) Should sequence diagram assertions be part of the assertions production,
 *    or separate as with probabilistic assertions?
 * 1) Should the context of the diagram be part of its definition, or part of
 *    the assertion (eg 'assertion X: MODULE satisfies DIAGRAM')?
 * 2) When the actors in a diagram are the platform and the design, what should
 *    the design be called?  Currently it's 'module', which may be confusing.
 * 3) Is the given way to describe PSP scopes appropriate?
 * 4) How do we describe strict vs weak ordering?  Which should be implicit?
 *    Right now, strict ordering is explicit all the way to the end, when
 *    we default to weak ordering - a bit strange.
 * 5) How do we describe timing properties?
 */

/**
 * A sequence diagram.
 */
Sequence:
	'sequence' name=ID 'for' target=Target ',' world=World body=Subsequence
;

/**
 * A subsequence.
 */
Subsequence:
	'{' (steps+=SequenceStep) ('then' steps+=SequenceStep)* '}'
;

/**
 * The target actor of a sequence diagram.
 */
Target:
	BasicTarget instantiation=TargetInstantiation 'as' name=ID
;

/**
 * A target override in a sequence diagram.
 */
TargetInstantiation:
	{TargetInstantiation} ('with' '{' (constants += ConstAssignment) (',' constants += ConstAssignment)* '}')?
;

/**
 * Various synonyms for assignment.
 */
fragment AssignWords *:
	'set' 'to' | 'assigned'
;

/**
 * A constant assignment.
 */
ConstAssignment:
	key=[Variable] AssignWords value=Expression
;

/**
 * A target of a sequence diagram.
 */
BasicTarget returns Target:
	 'module' {RCModuleTarget} module=[RCModule|QualifiedName]
;

/**
 * The world actor of a sequence diagram.
 */
World:
	'world' 'as' name=ID
;

// The basic trace is 'X then X then X... end'.  We can change to weak
// ordering by adding 'when' before X, or at the end by removing 'end'.
//
// As we improve the language, we'll want to capture property specification
// patterns (PSPs).
// The PSP scopes correspond to the following trace step sequences:
// 
// 'globally' => X
// 'after Q'  => anything until Q then X
// 'between Q and R' => ??
// 'after Q until R' => ??

/**
 * A step in a sequence diagram.
 */
SequenceStep:
	gap=SequenceGap action=SequenceAction
;

/**
 * An action in a sequence diagram.
 */
SequenceAction:
	{ArrowAction} body=ArrowMessageSpec |
	'loop' {LoopAction} name=ID body=Subsequence |
	'end' {FinalAction}
;

/**
 * A gap specification.
 */
SequenceGap:
	'anything' {LooseGap} allowed=AllowSet forbidden=ForbidSet  'until' |
	{StrictGap}
;

/**
 * A gap message set that defaults to being empty, but may be extended with 'in {...}'.
 */
AllowSet returns GapMessageSet:
	{GapMessageSet} ('in' GapMessageSetTail)?
;

/**
 * A gap message set that defaults to being empty, but may be extended with 'except {...}'.
 */
ForbidSet returns GapMessageSet:
	{GapMessageSet} ('except' GapMessageSetTail)?
;

/**
 * The common part of a gap message set.
 */
fragment GapMessageSetTail *:
	'{' messages+=GapMessageSpec (',' messages+=GapMessageSpec)* '}'
;

/**
 * An arrow message specification.
 */
ArrowMessageSpec:
	// Fragments don't seem to work for these...
	topic=MessageTopic 'from' from=[Actor] 'to' to=[Actor]
;

/**
 * A gap message specification.
 */
GapMessageSpec:
	topic=MessageTopic 'from' from=[Actor] 'to' to=[Actor]
;

/**
 * A message topic.
 */
MessageTopic:
	'event' {EventTopic} event=[Event|QualifiedName] ArgList |
	'operation' {OperationTopic} operation=[OperationSig|QualifiedName] ArgList
;

/**
 * An event or operation argument list.
 */
fragment ArgList:
	// need arguments
	('(' ')')?
;

/**
 * A RoboCert named assertion.
 */
NamedAssertion:
	'assertion' name=ID ':' body=Assertion
;

/**
 * A RoboCert assertion body.
 */
Assertion:
	SequenceAssertion
;
	
/**
 * A sequence assertion.
 *
 * These are:
 *
 * - assertion ID: SEQUENCE is observed (in CSP: sequence refines target)
 * - assertion ID: SEQUENCE is not observed (in CSP: sequence does not refine target)
 * - assertion ID: SEQUENCE holds (in CSP: target refines sequence)
 * - assertion ID: SEQUENCE does not hold (in CSP: target does not refine sequence)
 */
SequenceAssertion:
	sequence=[Sequence]
		( 'is' isNegated?='not' type=IsSequenceAssertionType
        | 'does' isNegated?='not' type=DoesNotSequenceAssertionType
        | type=DoesSequenceAssertionType
        )
    instantiation=TargetInstantiation
;

/**
 * Assertion types that agree with 'is' and 'is not'.
 */
enum IsSequenceAssertionType returns SequenceAssertionType:
	IS_OBSERVED='observed'
;

/**
 * Assertion types that agree with 'does not'.
 */
enum DoesNotSequenceAssertionType returns SequenceAssertionType:
	HOLDS='hold'
;

/**
 * Assertion types that agree without a prefix (eg, the opposite of
 * 'does not' assertion types).
 */
enum DoesSequenceAssertionType returns SequenceAssertionType:
	HOLDS='holds'
;