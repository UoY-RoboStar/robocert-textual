// automatically generated by Xtext
grammar robocalc.robocert.RoboCert with org.eclipse.xtext.common.Terminals

import "robocalc.robocert.model" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/**
 * A top-level diagram.
 */
Package:
	(sequences+=Sequence |
	 assertions += Assertion )*;
	
///////////////////////////////////////////////////////////////////////////////
// Sequence diagrams
///////////////////////////////////////////////////////////////////////////////

/*
 * Open design questions:
 * 
 * 0) Should sequence diagram assertions be part of the assertions production,
 *    or separate as with probabilistic assertions?
 * 1) Should the context of the diagram be part of its definition, or part of
 *    the assertion (eg 'assertion X: MODULE satisfies DIAGRAM')?
 * 2) When the actors in a diagram are the platform and the design, what should
 *    the design be called?  'Design' sounds a bit strange.
 * 3) Is the given way to describe PSP scopes appropriate?
 * 4) How do we describe strict vs weak ordering?  Which should be implicit?
 * 5) How do we describe timing properties?
 */

/**
 * A sequence diagram.
 */
Sequence:
	'sequence' name=ID 'in' target=SequenceTarget 'with' (actors+=SequenceActor (',' actors+=SequenceActor)*) '{'
		(steps+=SequenceStep)
		('then' steps+=SequenceStep)*
		(isStrictEnd?='end')?
	'}'	
;

/**
 * The target of a sequence diagram.
 */
SequenceTarget:
	// This should be a QualifiedName when we merge with RoboCert.
	{ModuleSequenceTarget} 'module' (moduleName=ID)
;

/**
 * A participant in a sequence diagram.
 */
SequenceActor:
	{PlatformSequenceActor} 'platform' name=ID |
	{ModuleSequenceActor} 'module' name=ID
;

// The basic trace is 'when X then X then X...', capturing a partial snippet of
// 
// 
//
// The PSP scopes correspond to the following trace step sequences:
// 
// 'globally' => X
// 'after Q'  => when Q then X
// 'between Q and R' => ??
// 'after Q until R' => ??

/**
 * A step in a sequence diagram.
 */
SequenceStep:
	{LooseSequenceStep} 'when' (arrow = SequenceArrow) |
	// Represents a sequence that begins live.
	{StrictSequenceStep} (arrow = SequenceArrow)
;

/**
 * An arrow (communication between participants).
 */
SequenceArrow:
	(body=SequenceArrowBody) 'from' from=[SequenceActor] 'to' to=[SequenceActor]
;

/**
 * An arrow body.
 */
SequenceArrowBody:
	// need arguments
	{EventSequenceArrowBody} 'event' eventName=ID ('(' ')')? |
	{OperationSequenceArrowBody} 'operation' opName=ID '(' ')'
;

//
// Sequence assertions
//
// These are:
//
// - assertion ID: SEQUENCE is witnessed
//     (in CSP: sequence refines design)
// - assertion ID: SEQUENCE is not witnessed
//     (in CSP: sequence does not refine design)
//

/**
 * A RoboCert assertion.
 */
Assertion:
	'assertion' name=ID ':' body=AssertionBody
;

/**
 * A RoboCert assertion body.
 */
AssertionBody:
	{WitnessingSequenceAssertionBody} sequence=[Sequence] 'is' (isNegated?='not')? 'witnessed'
;