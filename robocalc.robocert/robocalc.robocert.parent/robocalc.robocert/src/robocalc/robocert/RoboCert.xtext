// automatically generated by Xtext
grammar robocalc.robocert.RoboCert with circus.robocalc.robochart.textual.RoboChart

import "http://robocert.robocalc/" 
import "http://www.robocalc.circus/RoboChart"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/**
 * A top-level assertions package.
 */
RAPackage:
	( cspFragments += CSPFragment
	| sequenceGroups += SequenceGroup
	| assertions += Assertion
	)*;

/**
 * A raw CSP fragment.
 * 
 * TODO: per meta-model, these will likely go away later on, replaced with
 *       process-bound CSP fragments only.
 */

CSPFragment:
	'include' contents = CSP_CODE;

terminal CSP_CODE: 'csp-begin' -> 'csp-end';

///////////////////////////////////////////////////////////////////////////////
// Sequence diagrams
///////////////////////////////////////////////////////////////////////////////

/**
 * A sequence diagram group.
 * 
 * Sequence diagram groups contain a target and world, and then a mix of
 * sequences and message sets.
 */
SequenceGroup:
	'sequence' 'group' name=ID ':' target=Target '->' world=World
	'{'
	(sequences+=Sequence | messageSets += NamedMessageSet)*
	'}'
;

/**
 * A sequence diagram.
 */
Sequence:
	'sequence' name=ID body=Subsequence
;

/**
 * A subsequence.
 */
Subsequence:
	'{' (steps+=SequenceStep) ('then' steps+=SequenceStep)* '}'
;

/**
 * The target actor of a sequence diagram.
 */
Target:
	BasicTarget instantiation=TargetInstantiation
;

/**
 * A target override in a sequence diagram.
 */
TargetInstantiation:
	{TargetInstantiation} ('with' '{' (constants += ConstAssignment) (',' constants += ConstAssignment)* '}')?
;

/**
 * Various synonyms for assignment.
 */
fragment AssignWords *:
	'set' 'to' | 'assigned'
;

/**
 * A constant assignment.
 */
ConstAssignment:
	key=[Variable|QualifiedName] AssignWords value=Expression
;

/**
 * A target of a sequence diagram.
 */
BasicTarget returns Target:
	 'module' {RCModuleTarget} module=[RCModule|QualifiedName]
;

/**
 * The world actor of a sequence diagram.
 */
World:
	'world' {World}
;

// The basic trace is 'X then X then X... end'.  We can change to weak
// ordering by adding 'when' before X, or at the end by removing 'end'.
//
// As we improve the language, we'll want to capture property specification
// patterns (PSPs).
// The PSP scopes correspond to the following trace step sequences:
// 
// 'globally' => X
// 'after Q'  => anything until Q then X
// 'between Q and R' => ??
// 'after Q until R' => ??

/**
 * A step in a sequence diagram.
 */
SequenceStep:
	'within' {DeadlineStep} units=TimeUnits body=Subsequence |
	LoopStep |
	{ActionStep} gap=Gap action=SequenceAction
;

/**
 * An action in a sequence diagram.
 */
SequenceAction:
	{ArrowAction} body=MessageSpec |
	'after' {WaitAction} units=TimeUnits |
	'end' {FinalAction}
;

/**
 * A time unit expression.
 */
TimeUnits returns Expression:
	Expression 'time'? ('unit' | 'units')
;

/**
 * A loop.
 * 
 * Without a specification, loops will iterate forever.
 */
LoopStep:
	'loop' {LoopStep} name=ID (':' bound=LoopBound | bound=SilentInfiniteLoopBound) body=Subsequence
;

/**
 * A loop bound.
 */
LoopBound:
	'forever' {InfiniteLoopBound} |
	'exactly' {DefiniteLoopBound} times=Expression 'times' |
	'at' 'least' {LowerLoopBound} lowerTimes=Expression 'times' |
	'between' {RangeLoopBound} lowerTimes=Expression 'and' upperTimes=Expression 'times'
;

/**
 * Used to default to an infinite loop bound if none is explicitly given.
 */
SilentInfiniteLoopBound returns LoopBound:
	{InfiniteLoopBound}
;

/**
 * A gap specification.
 */
Gap returns MessageSet:
	'anything' AllowSet 'until' | EmptySet
;

/**
 * The topmost level of a gap set specification, one of:
 * 
 * - 'in X';
 * - 'in X except Y';
 * - 'except Y';
 * - '' (universe implied).
 */
AllowSet returns MessageSet:
	'in' MessageSet |
	{UniverseMessageSet} ({BinaryMessageSet.lhs=current} operator=DiffOperator rhs=UnionOrInterSet)?
;

/**
 * The main top-level rule for message sets, after accounting for the
 * possible omission of 'in X' in an 'anything except Y' stanza.
 */
MessageSet:
	UnionOrInterSet ({BinaryMessageSet.lhs = current} (operator=DiffOperator) rhs=UnionOrInterSet)*
;

/**
 * Factored-out level for union or intersection sets.
 */
UnionOrInterSet returns MessageSet:
	PrimitiveSet ({BinaryMessageSet.lhs = current} (operator=UnionOrInterOperator) rhs=PrimitiveSet)*
;

/**
 * Union or intersection operator literals.
 */
enum UnionOrInterOperator returns BinarySetOperator:
	UNION='or' |
	INTERSECTION='and'
;

/**
 * Difference operator literal.
 */
enum DiffOperator returns BinarySetOperator:
	DIFFERENCE='except'
;

/**
 * Pseudo-rule that pulls a gap message set to empty if we don't see an
 * explicit rule.
 */
EmptySet returns ExtensionalMessageSet:
	{ExtensionalMessageSet}
;

/**
 * A primitive message set.
 */
PrimitiveSet returns MessageSet:
	'(' MessageSet ')' |
	'universe' {UniverseMessageSet} |
	ExtensionalMessageSet |
	'message'? 'set' {RefMessageSet} set=[NamedMessageSet]
;

/**
 * An extensional message set (including singleton message sets).
 */
ExtensionalMessageSet:
	'{|' {ExtensionalMessageSet} messages+=MessageSpec (',' messages+=MessageSpec)* '|}' |
	messages+=MessageSpec
;

/**
 * A named message set.
 */
NamedMessageSet:
	'message' 'set' name=ID ':' set=MessageSet
;

/**
 * A message specification.
 */
MessageSpec:
	 direction=MessageDirection topic=MessageTopic ('(' (arguments+=Argument (',' arguments+=Argument)*)? ')')?
;

/**
 * The direction of a message.
 */
enum MessageDirection:
	INBOUND='<-' |
	OUTBOUND='->'
;

/**
 * An argument pattern.
 */
Argument:
	ExpressionArgument |
	{RestArgument} '...'
;

ExpressionArgument:
	expr=Expression
;

/**
 * A message topic.
 */
MessageTopic:
	'event' {EventTopic} event=[Event|QualifiedName] |
	('op'|'operation') {OperationTopic} operation=[OperationSig|QualifiedName]
;

///////////////////////////////////////////////////////////////////////////////
// Assertions
///////////////////////////////////////////////////////////////////////////////

/**
 * A RoboCert assertion.
 */
Assertion:
	SequenceAssertion
;

fragment AssertionName *:
	'assertion' name=ID ':'
;

/**
 * A sequence assertion.
 *
 * These are:
 *
 * - assertion ID: SEQUENCE is observed (in CSP: sequence refines target)
 * - assertion ID: SEQUENCE is not observed (in CSP: sequence does not refine target)
 * - assertion ID: SEQUENCE holds (in CSP: target refines sequence)
 * - assertion ID: SEQUENCE does not hold (in CSP: target does not refine sequence)
 */
SequenceAssertion:
	AssertionName
	sequence=[Sequence|QualifiedName]
		( 'is' isNegated?='not' type=IsSequenceAssertionType
        | 'does' isNegated?='not' type=DoesNotSequenceAssertionType
        | type=DoesSequenceAssertionType
        )
    instantiation=TargetInstantiation
;

/**
 * Assertion types that agree with 'is' and 'is not'.
 */
enum IsSequenceAssertionType returns SequenceAssertionType:
	IS_OBSERVED='observed'
;

/**
 * Assertion types that agree with 'does not'.
 */
enum DoesNotSequenceAssertionType returns SequenceAssertionType:
	HOLDS='hold'
;

/**
 * Assertion types that agree without a prefix (eg, the opposite of
 * 'does not' assertion types).
 */
enum DoesSequenceAssertionType returns SequenceAssertionType:
	HOLDS='holds'
;