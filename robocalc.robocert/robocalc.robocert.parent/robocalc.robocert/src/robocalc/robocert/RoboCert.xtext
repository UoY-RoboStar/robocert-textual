/**
 * The RoboCert grammar.
 *
 * Where possible, we try to keep this grammar's layout in line with that of
 * the Emfatic source of the RoboCert metamodel.
 */
grammar robocalc.robocert.RoboCert with circus.robocalc.robochart.textual.RoboChart

import "http://robocert.robocalc/"
import "http://www.robocalc.circus/RoboChart"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

///////////////////////////////////////////////////////////////////////////////
// CORE LANGUAGE
///////////////////////////////////////////////////////////////////////////////
/**
 * A top-level RoboCert package.
 */
CertPackage:
	(targets+=Target | groups+=(CSPGroup | SequenceGroup | AssertionGroup))*;

//
// TARGETS
//

/**
 * A target of a sequence diagram.
 */
Target:
	'target' (ModuleTarget | ControllerTarget);

// TODO(@MattWindsor91): it'd be nice to factor out the 'name=ID :' bit here,
// but I'm unsure how to without complicating the metamodel.

ModuleTarget:
	name=ID ':' 'module' module=[RCModule|QualifiedName];

ControllerTarget:
	name=ID ':' 'controller' controller=[ControllerDef|QualifiedName];

/**
 * A target override in a sequence diagram.
 */
Instantiation:
	{Instantiation} ('with' BEGIN (assignments+=ConstAssignment)+ END)?;

/**
 * A constant assignment.
 * 
 * As with many such lists, the definition of ConstAssignment allows commas
 * with an optional trailing (potentially Oxford-style) 'and'.
 */
ConstAssignment:
	ConstName (',' ConstName)* (','? 'and' ConstName)? AssignWords value=Expression;

/**
 * Adds a constant to the constants list.
 */
fragment ConstName *:
	constants+=[Variable|QualifiedName];

/**
 * Various synonyms for assignment.
 */
fragment AssignWords *:
	'set' 'to' | 'assigned';

/* RoboCert is whitespace-sensitive, with these terminals delimiting blocks
 * where a change of indentation must happen.
 * 
 * See:
 * https://www.eclipse.org/Xtext/documentation/307_special_languages.html#whitespace-aware-languages
 */
terminal BEGIN:
	'synthetic:BEGIN';

terminal END:
	'synthetic:END';

//
// ASSERTIONS
//
/**
 * An assertion group.
 * 
 * As syntactic sugar, unnamed assertion groups with only one assertion may be
 * written as if they were just lone Assertions.
 */
AssertionGroup:
	'assertion' (SingletonAssertionGroup | FullAssertionGroup);

/**
 * Produces the body of a singleton assertion group.
 * 
 * The instantiation of such a group appears at the end of the assertion.
 */
SingletonAssertionGroup returns AssertionGroup:
	assertions+=Assertion;

/**
 * Produces the body of a non-singleton assertion group.
 */
FullAssertionGroup returns AssertionGroup:
	{AssertionGroup} 'group' (name=ID)? ':' BEGIN ('assertion' assertions+=Assertion)* END;

/**
 * An assertion, less the leading 'assertion' keyword (because this might be
 * the end of a singleton AssertionGroup).
 * 
 * Assertions may break over whitespace, for readability.
 */
Assertion:
	name=ID ':' (property=Property | BEGIN property=Property END);

/**
 * Top-level disjunction of properties.
 */
Property:
	CoreProperty | "csp" {CSPProperty} contents=INTERPOLATE | SequenceProperty;

/**
 * Core properties with only one argument.
 */
CoreProperty:
	subject=[Target|QualifiedName]
	('is' (negated?='not')? type=IsCorePropertyType |
	type=VerbCorePropertyType |
	'does' (negated?='not')? type=DoesCorePropertyType);

// This factoring of an enumeration into 'is', 'does', and 'does not' is common
// in the RoboCert assertions language.
/**
 * Unary core property types that agree with 'is'/'is not'.
 */
enum IsCorePropertyType returns CorePropertyType:
	DEADLOCK_FREE='deadlock-free' |
	DETERMINISM='deterministic' |
	TIMELOCK_FREE='timelock-free';

/**
 * Unary core property types that are standalone verbs in the third
 * person present tense.
 */
enum VerbCorePropertyType returns CorePropertyType:
	// Remember to add these to DoesNot also.
	TERMINATION='terminates';

/**
 * Unary core property types that agree with 'does'/'does not'.
 */
enum DoesCorePropertyType returns CorePropertyType:
	// Remember to add these to Verb also.
	TERMINATION='terminate';

/**
 * A time unit expression.
 */
TimeUnits returns Expression:
	Expression 'time'? ('unit' | 'units');

//
// MODALITIES
//
/**
 * Captures an optional temperature with no other related side-material.
 */
fragment OptTemperature *:
	('(' temperature=Temperature ')')?;

/**
 * A temperature specification.
 */
enum Temperature:
	COLD='cold' |
	HOT='hot';

///////////////////////////////////////////////////////////////////////////////
// LOW-LEVEL LANGUAGES
///////////////////////////////////////////////////////////////////////////////
//
// CSP
//
/**
 * A CSP group.
 */
CSPGroup:
	'csp' (SingletonCSPGroup | FullCSPGroup);

SingletonCSPGroup returns CSPGroup:
	(('(' untimed?='untimed' ')')? &
	// This should be the same as the version in SequenceGroup
	('for' target=[Target|QualifiedName] instantiation=Instantiation))
	fragments+=CSPFragment;

FullCSPGroup returns CSPGroup:
	'group'
	(('(' untimed?='untimed' ')')? &
	// This should be the same as the version in SequenceGroup
	('for' target=[Target|QualifiedName] instantiation=Instantiation))
	':' BEGIN fragments+=CSPFragment* END;

//
// CSP fragments
//
/**
 * A CSP fragment.
 */
CSPFragment:
	'csp' contents=INTERPOLATE;

/**
 * Interpolation of low-level languages.
 */
terminal INTERPOLATE:
	'<$'->'$>';

//
// CSP properties
//

/**
 * Explicitly specifying the CSP model of a property.
 * 
 * TODO(@MattWindsor91): there may need to be more abstract ways of specifying
 * these models eventually.
 */
fragment InCSPModelSpec *:
	'in' 'the' model=CSPModel 'model';

/**
 * Names of CSP models.
 */
enum CSPModel:
	TRACES='traces' |
	TICK_TOCK='tick-tock';

///////////////////////////////////////////////////////////////////////////////
// SEQUENCES
///////////////////////////////////////////////////////////////////////////////
/**
 * A sequence diagram group.
 * 
 * Sequence diagram groups contain a target and world, and then a mix of
 * sequences and message sets.
 */
SequenceGroup:
	'sequence' 'group' name=ID?
	// This should be the same as the version in CSPGroup
	'for' target=[Target|QualifiedName] instantiation=Instantiation
	':'
	BEGIN
	(ActorList | interactions+=Interaction | messageSets+=NamedMessageSet)*
	END;

fragment ActorList *:
	// should match 'use X', 'use X, Y', 'use X and Y', 'use X, Y and Z',
	// 'use X, Y, and Z', and so on.
	'use' actors+=Actor (',' actors+=Actor)* (','? 'and' actors+=Actor)?
;

/**
 * A sequence diagram.
 */
Interaction:
	'sequence' name=ID ':' BEGIN
	'use' actors+=[Actor] (',' actors+=[Actor])* (','? 'and' actors+=[Actor])?
	(variables=InteractionVars)?
	Subsequence
	END;

/**
 * An interaction variable list (may be empty).
 */
InteractionVars returns VariableList:
	{VariableList}
	modifier=InteractionVarsModifier vars+=Variable (',' vars+=Variable)* (','? 'and' vars+=Variable)?
;

/**
 * Subset of variable modifiers permitted on an interaction.
 */
enum InteractionVarsModifier returns VariableModifier:
	// Ill-formed to use const here
	VAR='var'
;

/**
 * A subsequence.
 * 
 * Subsequences can either be empty ('nothing'), or a nonzero sequence of
 * steps ('x then y then...').
 */
fragment Subsequence *:
	'nothing' | (fragments+=InteractionFragment)+;

/**
 * An interaction operand that may or may not be guarded.
 */
InteractionOperand:
	GuardedInteractionOperand | guard=ImplicitEmptyGuard Subsequence
;

/**
 * A guarded interaction operand.
 */
GuardedInteractionOperand returns InteractionOperand:
	guard=Guard ':' BEGIN Subsequence END;


/**
 * An interaction operand with no guard and one item.
 */
SingletonInteractionOperand returns InteractionOperand:
	guard=ImplicitEmptyGuard fragments+=InteractionFragment
;

/**
 * An explicit guard.
 */
Guard:
	'always' {EmptyGuard} |
	'otherwise' {ElseGuard} |
	'when' {ExprGuard} expr=Expression;

/**
 * Consumes nothing and instantly returns an empty guard.
 */
ImplicitEmptyGuard returns EmptyGuard:
	{EmptyGuard}
;

//
// INTERACTION FRAGMENTS
//
/**
 * A step in a sequence diagram.
 */
InteractionFragment:
	BlockFragment |
	BranchFragment |
	{OccurrenceFragment} occurrence=Occurrence OptTemperature |
	UntilFragment;

fragment BlockFragmentTail *:
	':' BEGIN body=InteractionOperand END
;

/**
 * An until-fragment.
 */
UntilFragment:
	(('any' | 'anything') {UntilFragment} intraMessages=IntraMessageSet | 'block' {UntilFragment} intraMessages=EmptySet)
	'until' (body=SingletonInteractionOperand | BlockFragmentTail);

//
// Block fragments
//
/**
 * A block fragment.
 */
BlockFragment:
	(DurationFragment |
	('opt' | 'optional') {OptFragment} OptTemperature |
	'loop' {LoopFragment} bound=MaybeLoopBound) ('as' name=ID)? BlockFragmentTail;

DurationFragment:
	'taking'
	('at' 'least' lowerBound = TimeUnits ('and' 'at' 'most' upperBound = TimeUnits)? |
	'at' 'most' upperBound = TimeUnits);

//
// Loop bounds
//
/**
 * A loop bound, possibly.  Defaults to InfiniteLoopBound.
 */
MaybeLoopBound returns LoopBound:
	{InfiniteLoopBound} | '(' LoopBound ')';

/**
 * A loop bound.
 */
LoopBound:
	'forever' {InfiniteLoopBound} |
	'exactly' {DefiniteLoopBound} times=Expression 'times' |
	'at' 'least' {LowerLoopBound} lowerTimes=Expression 'times' |
	'between' {RangeLoopBound} lowerTimes=Expression 'and' upperTimes=Expression 'times';

//
// Branch steps
//
/**
 * A branching construct.
 */
BranchFragment:
	(('par' | 'parallel') {ParFragment} |
	('alt' | 'alternative') {AltFragment} OptTemperature) ':' BEGIN branches+=GuardedInteractionOperand (branches+=GuardedInteractionOperand)+ END;

//
// OCCURRENCES
//
/**
 * An occurrence in a sequence diagram.
 */
Occurrence:
	{MessageOccurrence} message=Message |
	LifelineOccurrence;

LifelineOccurrence:
	('after' {WaitOccurrence} units=TimeUnits |
	'deadlock' {DeadlockOccurrence}) 'on' actor=[Actor|QualifiedName];

//
// MESSAGES
//
/**
 * A message specification.
 */
Message:
	topic=MessageTopic ('(' (arguments+=ValueSpecification (',' arguments+=ValueSpecification)*)? ')')? edge=Edge;

/**
 * An edge.
 */
Edge:
	{ImplicitEdge} direction=EdgeDirection? |
	'from' {ExplicitEdge} from=[Actor|ID] 'to' to=[Actor|ID];

/**
 * The direction of an implicit edge.
 */
enum EdgeDirection:
	INBOUND='in' |
	OUTBOUND='out';

//
// Message topics
//
/**
 * A message topic.
 */
MessageTopic:
	'event' {EventTopic} event=[Event|QualifiedName] |
	('op' | 'operation') {OperationTopic} operation=[OperationSig|QualifiedName];

//
// Message sets
//
/**
 * A named message set.
 */
NamedMessageSet:
	'message' 'set' name=ID '=' set=MessageSet;

/**
 * The topmost level of an intra-message set specification, one of:
 * 
 * - 'in X';
 * - 'in X except Y';
 * - 'except Y';
 * - '' (universe implied).
 */
IntraMessageSet returns MessageSet:
	'in' MessageSet |
	{UniverseMessageSet} ({BinaryMessageSet.lhs=current} operator=DiffOperator rhs=UnionOrInterSet)?;

/**
 * The main top-level rule for message sets, after accounting for the
 * possible omission of 'in X' in an 'anything except Y' stanza.
 */
MessageSet:
	UnionOrInterSet ({BinaryMessageSet.lhs=current} (operator=DiffOperator) rhs=UnionOrInterSet)*;

/**
 * Factored-out level for union or intersection sets.
 */
UnionOrInterSet returns MessageSet:
	PrimitiveSet ({BinaryMessageSet.lhs=current} (operator=UnionOrInterOperator) rhs=PrimitiveSet)*;

/**
 * Union or intersection operator literals.
 */
enum UnionOrInterOperator returns BinarySetOperator:
	UNION='or' |
	INTERSECTION='and';

/**
 * Difference operator literal.
 */
enum DiffOperator returns BinarySetOperator:
	DIFFERENCE='except';

/**
 * Pseudo-rule that pulls a gap message set to empty if we don't see an
 * explicit rule.
 */
EmptySet returns ExtensionalMessageSet:
	{ExtensionalMessageSet};

/**
 * A primitive message set.
 */
PrimitiveSet returns MessageSet:
	'(' MessageSet ')' |
	'universe' {UniverseMessageSet} |
	ExtensionalMessageSet |
	'message'? 'set' {RefMessageSet} set=[NamedMessageSet];

/**
 * An extensional message set (including singleton message sets).
 */
ExtensionalMessageSet:
	'{' {ExtensionalMessageSet} messages+=Message (',' messages+=Message)* '}' |
	messages+=Message;

//
// Value specifications
//
/**
 * A value specification.
 */
ValueSpecification:
	{ExpressionValueSpecification} expr=Expression |
	{WildcardValueSpecification} ('any' | 'anything') ('as' destination=[Variable])?;

//
// ACTORS
//
Actor:
	('target' {TargetActor} | 'world' {World} | 'component' {ComponentActor} node=[ConnectionNode|QualifiedName]) 'as' name=ID;

//
// SEQUENCE PROPERTIES
//
/**
 * A sequence property.
 * 
 * These are:
 * 
 * - SEQUENCE is observed (in CSP: sequence refines target)
 * - SEQUENCE is not observed (in CSP: sequence does not refine target)
 * - SEQUENCE holds (in CSP: target refines sequence)
 * - SEQUENCE does not hold (in CSP: target does not refine sequence)
 */
SequenceProperty:
	interaction=[Interaction|QualifiedName]
	('is' negated?='not' type=IsSequencePropertyType
	| 'does' negated?='not' type=DoesNotSequencePropertyType
	| type=DoesSequencePropertyType)
	InCSPModelSpec?;

/**
 * Sequence property types that agree with 'is' and 'is not'.
 */
enum IsSequencePropertyType returns SequencePropertyType:
	IS_OBSERVED='observed';

/**
 * Sequence property types that agree with 'does not'.
 */
enum DoesNotSequencePropertyType returns SequencePropertyType:
	HOLDS='hold';

/**
 * Sequence property that agree without a prefix (eg, the opposite of
 * 'does not' sequence property types).
 */
enum DoesSequencePropertyType returns SequencePropertyType:
	HOLDS='holds';
