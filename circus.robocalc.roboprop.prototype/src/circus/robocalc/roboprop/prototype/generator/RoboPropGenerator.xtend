/*
 * generated by Xtext 2.25.0
 */
package circus.robocalc.roboprop.prototype.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import circus.robocalc.roboprop.prototype.roboProp.Sequence
import circus.robocalc.roboprop.prototype.roboProp.Assertion
import circus.robocalc.roboprop.prototype.roboProp.SequenceAssertionType
import circus.robocalc.roboprop.prototype.roboProp.ModuleSequenceContext
import circus.robocalc.roboprop.prototype.roboProp.SequenceContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class RoboPropGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		fsa.generateFile('seq.csp', generate(resource));
	}
	
	/**
	 * @return generated CSP for all elements.
	 * 
	 * @param resource  the top-level property model.
	 */
	def String generate(Resource resource) {
		'''
		{-
		 - Begin sequence generation
		 -}
		 
		«generateSequences(resource)»
		
		{-
		 - End sequence generation
		 -}
		
		
		{-
		 - Begin assertion generation
		 -}
		
		«generateAssertions(resource)»
		
		{-
		 - End assertion generation
		 -}
		'''
	}
	
	/**
	 * @return generated CSP for all sequences.
	 * 
	 * @param resource  the top-level property model.
	 */
	def String generateSequences(Resource resource) {
		'''
		«FOR seq : resource.allContents.filter(Sequence).toIterable»
			«generateSequence(seq)»
		«ENDFOR»
		'''
	}
	
	/**
	 * @return generated CSP for one sequence.
	 * 
	 * @param seq  the sequence for which we are generating CSP.
	 */
	def String generateSequence(Sequence seq) {
		'''
		«seq.name» = let
			Step0 = SKIP
		within Step0
		'''
	}
	
	/**
	 * @return generated CSP for all assertions.
	 * 
	 * @param resource  the top-level property model.
	 */
	def String generateAssertions(Resource resource) {
		'''
		«FOR asst : resource.allContents.filter(Assertion).toIterable»
			«generateAssertion(asst)»
		«ENDFOR»
		'''
	}
	
	/**
	 * @return generated CSP for one assertion.
	 * 
	 * @param asst  the assertion for which we are generating CSP.
	 */
	def String generateAssertion(Assertion asst) {
		var lhs = generateAssertionLeft(asst);
		var rhs = generateAssertionRight(asst);
		var model = generateAssertionModel(asst);
		'''
		-- Assertion «asst.name»
		assert«IF asst.negated» not«ENDIF» «lhs» [«model»= «rhs»
		'''
	}
	
	/**
	 * Generates CSP for the left-hand side of the assertion.
	 * 
	 * Depending on the assertion type, this may expand to the sequence or the
	 * target of the sequence.
	 * 
	 * @param asst  the assertion for which we are generating CSP.
	 * 
	 * @return generated CSP for the left-hand side of the assertion.
	 */
	def String generateAssertionLeft(Assertion asst) {
		switch asst.type {
			case SequenceAssertionType.WITNESSED:
				generateAssertionSeqRef(asst)
		}
	}
	
	/**
	 * Generates CSP for the right-hand side of the assertion.
	 * 
	 * Depending on the assertion type, this may expand to the sequence or the
	 * target of the sequence.
	 * 
	 * @param asst  the assertion for which we are generating CSP.
	 * 
	 * @return generated CSP for the right-hand side of the assertion.
	 */
	def String generateAssertionRight(Assertion asst) {
		switch asst.type {
			case SequenceAssertionType.WITNESSED:
				generateAssertionTarget(asst)
		}
	}
	
	/**
	 * @return generated CSP for a sequence reference in one assertion.
	 * 
	 * @param asst  the assertion for which we are generating CSP.
	 */
	def String generateAssertionSeqRef(Assertion asst) {
		asst.element.name
	}

	/**
	 * @return generated CSP for the target of one assertion.
	 * 
	 * @param asst  the assertion for which we are generating CSP.
	 */
	def String generateAssertionTarget(Assertion asst) {
		generateAssertionTargetFromContext(asst.element.context)
	}
	
	/**
	 * @return generated CSP for the target of one assertion's context.
	 * 
	 * @param ctx  the context for which we are generating CSP.
	 */
	def String generateAssertionTargetFromContext(SequenceContext ctx) {
		switch ctx {
			ModuleSequenceContext: '''P_«ctx.name»'''
		}
	}
	
	/**
	 * @return the appropriate FDR model shorthand for this assertion.
	 */
	def String generateAssertionModel(Assertion _) {
		// TODO: allow other assertion models
		"T"
	}
}
