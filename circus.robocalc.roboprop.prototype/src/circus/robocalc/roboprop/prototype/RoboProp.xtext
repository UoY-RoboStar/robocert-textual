grammar circus.robocalc.roboprop.prototype.RoboProp with org.eclipse.xtext.common.Terminals

generate roboProp "http://www.robocalc.circus/roboprop/prototype/RoboProp"

Model:
	(sequences+=Sequence |
	 assertions += Assertion )*;
	
///////////////////////////////////////////////////////////////////////////////
// Sequence diagrams
///////////////////////////////////////////////////////////////////////////////

/*
 * Open design questions:
 * 
 * 0) Should sequence diagram assertions be part of the assertions production,
 *    or separate as with probabilistic assertions?
 * 1) Should the context of the diagram be part of its definition, or part of
 *    the assertion (eg 'assertion X: MODULE satisfies DIAGRAM')?
 * 2) When the actors in a diagram are the platform and the design, what should
 *    the design be called?  'Design' sounds a bit strange.
 * 3) Is the given way to describe PSP scopes appropriate?
 * 4) How do we describe strict vs weak ordering?  Which should be implicit?
 * 5) How do we describe timing properties?
 */

Sequence:
	'sequence' name=ID 'in' context=SequenceContext '{'
		(elements+=SequenceElement*)
	'}'	
;


SequenceContext:
	// This should be a QualifiedName when we merge with RoboCert.
	{ModuleSequenceContext} 'module' (name=ID)
;

SequenceElement:
	SequenceActorSet |
	SequenceTrace
;

SequenceActorSet:
	'with' actors+=SequenceActor (',' actors+=SequenceActor)
;

SequenceActor:
	{PlatformSequenceActor} 'platform' name=ID |
	{DesignSequenceActor} 'design' name=ID
;

// The basic trace is 'when X then X then X...', capturing a partial snippet of
// 
// 
//
// The PSP scopes correspond to the following trace step sequences:
// 
// 'globally' => first X
// 'after Q'  => when Q then X
// 'between Q and R' => ??
// 'after Q until R' => ??
SequenceTrace:
	(steps+=SequenceTraceStart) (steps+=SequenceTraceStep*) (steps+=SequenceTraceEnd)?
;

SequenceTraceStart returns SequenceTraceElement:
	// Represents a sequence that becomes live when an action matching this specification occurs.
	{WhenSequenceTraceElement} 'when' (action = SequenceAction) |
	// Represents a sequence that begins live.
	{FirstSequenceTraceElement} 'first' (action = SequenceAction)
;

SequenceTraceStep returns SequenceTraceElement:
	{ThenSequenceTraceElement} 'then' (action = SequenceAction)
;

SequenceTraceEnd returns SequenceTraceElement:
	{FinallySequenceTraceElement} 'finally' (action = SequenceAction)
;

// An action is an arrow between participants.
SequenceAction:
	SequenceArrow 'from' from=[SequenceActor] 'to' to=[SequenceActor]
;

SequenceArrow:
	// need arguments
	{EventSequenceArrow} 'event' name=ID ('(' ')')? |
	{OpSequenceArrow} 'operation' name=ID '(' ')'
;

/*
// The following is provisional.

SeqAnyAction:
	{SeqAnyAction} 'anything' (restriction=SeqAnyRestriction)?
;

SeqAnyRestriction:
	{SeqInRestriction} 'in' (restrict = SeqEventSet) |
	{SeqButRestriction} 'but' (restrict = SeqEventSet)
;

SeqEventSet:
	{SeqEventSet} '{' events+=SeqEventSet* '}'
;
*/

//
// Sequence assertions
//
// These are:
//
// - assertion ID: SEQUENCE is witnessed
//     (in CSP: sequence refines design)
// - assertion ID: SEQUENCE is not witnessed
//     (in CSP: sequence does not refine design)
//

Assertion:
	'assertion' name=ID ':' element=[Sequence] 'is' (negated?='not')? type=SequenceAssertionType
;

enum SequenceAssertionType:
	WITNESSED = 'witnessed' // Sequence represents a single trace that should (or should not) hold.
;