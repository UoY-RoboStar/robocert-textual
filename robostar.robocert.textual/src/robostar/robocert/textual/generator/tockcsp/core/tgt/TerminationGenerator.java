/*
 * Copyright (c) 2022 University of York and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 */

package robostar.robocert.textual.generator.tockcsp.core.tgt;

import com.google.inject.Inject;
import java.util.Objects;
import robostar.robocert.textual.generator.tockcsp.ll.csp.CSPEvent;
import robostar.robocert.textual.generator.tockcsp.ll.csp.CSPStructureGenerator;

/**
 * Handles the generation of references to the 'terminate' channel, sets containing the channel, and
 * attempts to hide it.
 *
 * <p>This class exists because lots of different parts of the target generation logic need it.
 *
 * @param csp the low-level CSP generator.
 * @author Alvaro Miyazawa (initial definition in RoboChart)
 * @author Pedro Ribeiro (initial definition in RoboChart)
 * @author Matt Windsor (port to RoboCert)
 */
public record TerminationGenerator(CSPStructureGenerator csp) {

  /**
   * Constructs a termination generator.
   *
   * @param csp the low-level CSP generator.
   */
  @Inject
  public TerminationGenerator {
    Objects.requireNonNull(csp);
  }

  /**
   * Constructs a fully-qualified reference to the termination channel.
   *
   * @param ns the namespace of the target element (if empty or null, omitted).
   * @return the terminate channel (not in a set).
   */
  public CSPEvent terminateEvent(CharSequence ns) {
    final var noName = ns == null || ns.isEmpty();
    final var fqid = noName ? TERM_CHANNEL : csp.namespaced(ns, TERM_CHANNEL);
    return new CSPEvent(fqid.toString());
  }

  /**
   * Constructs the CSP termination process.
   *
   * @return a process that emits the termination event then terminates.
   */
  public CharSequence terminateProc() {
    return csp.pre(terminateEvent(null), csp.skip());
  }

  /**
   * Constructs a set over a reference to the termination channel.
   *
   * @param ns the namespace of the target element.
   * @return the terminate channel (not in a set).
   */
  private CharSequence terminateSet(CharSequence ns) {
    return csp.sets().set(terminateEvent(ns).toString());
  }

  /**
   * Hides the termination channel inside a CSP-M process.
   *
   * @param ns   the namespace of the target element.
   * @param body the body in which the channel should be hidden.
   * @return the result of hiding {@code terminateSet(ns)} in {@code body}.
   */
  public CharSequence hideTerminate(CharSequence ns, CharSequence body) {
    return csp.bins().hide(body, terminateSet(ns));
  }

  /**
   * Sets up termination inside a CSP process.
   * <p>
   * This consists of an interrupt over the termination channel, followed by a hide of the same
   * channel.
   *
   * @param ns   the namespace of the target element.
   * @param body the body in which the channel should be hidden.
   * @return the result of hiding {@code terminateSet(ns)} in {@code body}.
   */
  public CharSequence handleTerminate(CharSequence ns, CharSequence body) {
    final var terminate = terminateSet(ns);
    final var terminated = csp.bins().interrupt(csp.tuple(body), terminate, csp.skip());

    // Could use hideTerminate, but then we'd be generating `terminate` twice.
    // (Bit of a micro-optimisation, mind.)
    return csp.bins().hide(terminated, terminate);
  }

  /**
   * The RoboCert termination channel, used on multi-lifeline sequences.
   *
   * <p>Not to be confused with the termination channels generated by the RoboChart semantics.
   */
  public static final String TERM_CHANNEL = "terminate";
}
